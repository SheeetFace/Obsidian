# dom-дерево
> [!help] 
> ###### DOM (Document Object Model)
**DOM** представляет собой объектную модель HTML-документа. Это дерево узлов, где каждый узел соответствует элементу HTML.
>> Например, простой HTML-документ:
>>будет представлен в виде дерева узлов, где <html> является корневым элементом, а <head> и <body> — его дочерними элементами.
>> ```html
>> <!DOCTYPE html>
>> <html>
>>  <head>
>>    <title>My First Web Page</title>
>>  </head>
>>  <body>
>>    <h1>Hello, world!</h1>
>>    <p>How are you?</p>
>>  </body>
>></html>
>>```
>
> ![[Pasted image 20240902114330.png]] 

# DOCTYPE
> [!help]
> **Doctype** (Document Type Declaration) — это специальная инструкция, которая помещается в начале `HTML-документа`, чтобы сообщить браузеру, какую версию `HTML` следует использовать для отображения страницы. Он не является `HTML-тегом`, а представляет собой декларацию. 
>
>>[!example]
>>```html 
>><!DOCTYPE html>
>>```

# Категории-контента-в-HTML5
> [!help]
ЮВ HTML5 категории контента — это группы элементов, организованные по их назначению и роли в структуре веб-страницы. Эти категории помогают разработчикам понимать, какие элементы могут быть использованы в определённых контекстах и как они взаимодействуют друг с другом.
>
>###### Основные категории контента в HTML5:
> 1. ***Секция (Sectioning Content)***:
>       - Элементы, которые используются для создания структуры документа и разделения его на логические секции. `<article> <aside> <nav> <section> `
> 2. ***Заголовок (Heading Content)***:
>       - Элементы, определяющие заголовки секций и статей. ` <h1>, <h2>, <h3>, <h4>, <h5>, <h6>`
> 3. ***Фразовый (Phrasing Content)***:
>        - Элементы, которые определяют текстовые блоки, например, слова, выражения и стилизованный текст. ` <span>, <strong>, <em>, <a>, <mark>`
> 4. ***Блоковый (Flow Content)***:
>       - Объединяет элементы, которые составляют основное содержимое страницы, включая секционные и текстовые элементы. ` <div>, <p>, <header>, <footer>`
> 5. ***Интерактивный (Interactive Content)***:
>       - Элементы, которые позволяют пользователю взаимодействовать с веб-страницей.` <button>, <a>, <input>, <textarea>`
> 6. ***Заголовок документа (Metadata Content)***:
>       - Элементы, которые содержат информацию о документе, например, заголовок, стили и кодировка. ` <title>, <meta>, <link>, <style> `
> 7. ***Элементы встроенного контента (Embedded Content)***:
>       - Элементы для вставки внешних ресурсов, таких как изображения, видео или объекты. `<img>, <iframe>, <embed>, <video>, <audio>`

# Data-атрибуты
> [!help]
>**Data-атрибуты** используются в HTML для хранения пользовательских данных в элементах веб-страницы. Они позволяют добавлять произвольные значения, которые можно динамически использовать через JS, не влияя на поведение или стиль страницы.
>
>###### Как выглядят data-атрибуты:
>    - Синтаксис: Data-атрибуты всегда начинаются с `data-`, за которым следует имя. 
>>[!example]
>>```html
>><div data-user-id="12345" data-role="admin">Пользователь</div>
>>```
>
>>[!example] Пример применения:
>> Допустим, у вас есть список товаров, и каждому товару нужно присвоить идентификатор и категорию:
>>```html
>><ul>
>>    <li data-id="1" data-category="books">Книга</li>
>>    <li data-id="2" data-category="electronics">Телефон</li>
>></ul>
>>```
>>С помощью JavaScript вы можете получить данные:
>>```js
>>const items = document.querySelectorAll('li');
>>items.forEach(item => {
>>    console.log(`ID: ${item.dataset.id}, Category: ${item.dataset.category}`);
>>});
>>```

# cssom
> [!help] 
> **CSSOM (CSS Object Model)**— это объектная модель CSS, которая представляет собой структуру всех стилей, примененных к элементам на странице. CSSOM создается из всех загруженных и распознанных стилей CSS.
>>```html
>><!DOCTYPE html>
>><html>
>>  <head>
>>    <style>
>>      body { background-color: lightblue; }
>>      h1 { color: navy; }
>>      p { color: red; }
>>    </style>
>>  </head>
>>  <body>
>>    <h1>Hello, world!</h1>
>>    <p>How are you?</p>
>>  </body>
>></html>
>>```


# html
> [!help] 
>**HTML (HyperText Markup Language)** — это язык гипертекстовой разметки, который используется для создания и структурирования веб-страниц. Он позволяет определять, как контент будет отображаться в браузере.
>###### Основные элементы HTML
>> HTML состоит из различных элементов, которые заключены в теги. Вот несколько основных тегов:
>> - ```<html>```: Корневой элемент, который содержит весь HTML-документ.
>> - ```<head>```: Содержит метаданные о документе, такие как `<title>`, `<meta>`, `<link>`.
>> - ```<title>```: Определяет заголовок страницы, который отображается на вкладке браузера.
>> - ```<body>```: Содержит основной контент страницы, такой как текст, изображения, ссылки и другие элементы.
>
> ```html
> <!DOCTYPE html>
> <html>
>  <head>
>    <title>My First Web Page</title>
>  </head>
>  <body>
>    <h1>Hello, world!</h1>
>    <p>How are you?</p>
>  </body>
></html>
>```

# async/defer
> [!help] 
> - Без **async** и **defer**: Скрипты выполняются сразу после загрузки, приостанавливая парсинг HTML.
> - С **async**: Скрипты выполняются сразу после загрузки, но парсинг HTML не останавливается.
> - С **defer**: Скрипты выполняются только после завершения парсинга HTML и создания DOM, перед началом рендеринга 
>> ```ts
>><script src="script.js" async></script>
>>```
>> ```ts
>><script src="script.js" defer></script>
>>```


# preload

> [!help] 
> **Preload** — это атрибут, который позволяет браузеру заранее загружать ресурсы, такие как скрипты, стили, шрифты и изображения, чтобы они были готовы к использованию, когда это потребуется.
> 
> ###### Как работает preload:
>>- **Preload** загружает ресурс в фоновом режиме, не останавливая парсинг HTML.
>> - Ресурс становится доступным, когда браузер доходит до точки, где он нужен, что ускоряет рендеринг страницы.
> 
>  ###### Пример:
>> - ***Шрифты***
>> ```html
>><link rel="preload" href="fonts/myfont.woff2" as="font" type="font/woff2" crossorigin="anonymous">
>>```
>>
>> - ***Скрипты (в комбинации с [defer или async](#async/defer))***
>> ```html
>><link rel="preload" href="script.js" as="script">
>><script src="script.js" defer></script>
>>
>  ###### Преимущества:
>> - Ускоряет загрузку критичных ресурсов.
>> - Уменьшает задержки при рендеринге страницы.
>> - Повышает производительность и улучшает пользовательский опыт.

 
# семантические-тэги
> [!help] 
> **Семантические теги** в [HTML](#html) дают браузеру и разработчикам понимание типа контента. 
>> - `<header>`: Заголовок веб-страницы или раздела.
>>  - `<nav>`: Навигационная ссылка. 
>>  - `<main>`: Основное содержимое веб-страницы. 
>>  - `<article>`: Самостоятельный контент, который имеет смысл вне контекста страницы. 
>>  - `<section>`: Раздел веб-страницы. 
>>  - `<aside>`: Содержимое, относящееся к основному контенту страницы, но которое можно отделить от него. 
>>  - `<footer>`: Подвал веб-страницы или раздела. Использование семантических тегов улучшает доступность сайта, помогает поисковым системам понять структуру контента и упрощает стилизацию страницы.
>
>Использование семантических тегов улучшает доступность сайта, помогает поисковым системам понять структуру контента и упрощает стилизацию страницы.

# babling-capturing
> [!help] 
>> [!quote] 
>> **Bubbling (всплытие)**  - событие распространяется от целевого элемента вверх по DOM-дереву.
>
>> [!quote] 
>> **Capturing (погружение)** - событие сначала обрабатывается на верхнем уровне, затем спускается к целевому элементу.
> ###### Использование в JavaScript
>>> [!info]
>>> **Третий аргумент в addEventListener** - Этот аргумент определяет, будет ли обработчик события вызван на фазе **capturing** (если true) или на фазе **bubbling** (если false или не указан).
>>> ```js
>>>element.addEventListener(event, handler, useCapture)
>>>```
>>>Где:
>>> - `event` - тип события (например, 'click')
>>> - `handler` - функция-обработчик события
>>> - `useCapture` - булево значение, определяющее, будет ли обработчик вызван на фазе capturing (true) или bubbling (false)
>>> 
>>>> [!example] 
>>>> ```html
>>>> <div id="outer">
>>>>   <div id="inner">
>>>>     <button id="button">Нажми меня</button>
>>>>   </div>
>>>> </div>
>>>> <script>
>>>> const outer = document.getElementById('outer');
>>>> const inner = document.getElementById('inner');
>>>> const button = document.getElementById('button');
>>>> outer.addEventListener('click', () => console.log('Outer (bubble)'));
>>>> inner.addEventListener('click', () => console.log('Inner (bubble)'));
>>>> button.addEventListener('click', () => console.log('Button (bubble)'));
>>>> outer.addEventListener('click', () => console.log('Outer (capture)'), true);
>>>> inner.addEventListener('click', () => console.log('Inner (capture)'), true);
>>>> button.addEventListener('click', () => console.log('Button (capture)'), true);
>>>> </script>
>>>
>>>> ###### Результат
>>>>| ***CAPTURE***      | ***BUBBLE***       |
>>>>|--------------------|--------------------|
>>>>| Outer (capture)    | Button (bubble)    |
>>>>| Inner (capture)    | Inner (bubble)     |
>>>>| Button (capture)   | Outer (bubble)     |
>>>> ###### Объяснение
>>>> 1. Сначала событие проходит фазу capturing сверху вниз (от outer к button).
>>>> 2. Затем происходит фаза target (сам клик на кнопке).
>>>> 3. После этого начинается фаза bubbling снизу вверх (от button к outer).
>>> 
>>> ###### Практическое применение в веб-разработке:
>>> 
>>> Перехват событий на ранней стадии:
>>> - Иногда нужно обработать событие до того, как оно достигнет целевого элемента. Например, для логирования или для предотвращения определенных действий.
>>> ```js
>>> document.addEventListener('click', (e) => {
>>>   if (e.target.tagName === 'BUTTON' && e.target.classList.contains('disabled')) {
>>>     e.preventDefault();
>>>     e.stopPropagation();
>>>    console.log('Клик по отключенной кнопке предотвращен');
>>>  }
>>>}, true);
>>>```
>>>Создание кастомных событий с особым поведением:
>>> - Можно создать событие, которое сначала обрабатывается на фазе capturing, а затем на фазе bubbling, что позволяет реализовать сложную логику обработки.
>>> - Оптимизация производительности:
>>> - В некоторых случаях использование capturing может быть более эффективным, особенно если нужно обработать событие только один раз на верхнем уровне DOM.
>>
>>>[!info]
>>> **В React есть onClickCapture**

# portals
> [!help] 
>> [!quote]
>> **HTML Порталы (Portal Element)** - HTML элемент `<portal>`, позволяющий предварительно отображать контент другой страницы в текущем документе
>>
>> **Базовое использование** - Создание портала на другую страницу
>>
>>```html
>><portal id="myPortal" src="https://example.com">
>>    <!-- Fallback контент, если браузер не поддерживает порталы -->
>>    <p>Ваш браузер не поддерживает порталы</p>
>></portal>
>>```
>>
>> **Стилизация портала** - Портал можно стилизовать как обычный элемент
>>
>>```css
>>#myPortal {
>>    width: 500px;
>>    height: 300px;
>>    border: none;
>>    border-radius: 10px;
>>}
>>```
>>
>> **Активация портала** - JavaScript для перехода по порталу
>>
>>```js
>>const portal = document.querySelector('#myPortal');
>>
>>// Активация портала при клике
>>portal.addEventListener('click', () => {
>>    portal.activate();
>>});
>>```
>>
>> **Обработка событий портала**
>>
>>```js
>>portal.addEventListener('portalactivate', () => {
>>    console.log('Портал активирован');
>>});
>>```