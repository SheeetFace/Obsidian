# dom-дерево
> [!help] 
> ###### DOM (Document Object Model)
**DOM** представляет собой объектную модель HTML-документа. Это дерево узлов, где каждый узел соответствует элементу HTML.
>> Например, простой HTML-документ:
>>будет представлен в виде дерева узлов, где <html> является корневым элементом, а <head> и <body> — его дочерними элементами.
>> ```html
>> <!DOCTYPE html>
>> <html>
>>  <head>
>>    <title>My First Web Page</title>
>>  </head>
>>  <body>
>>    <h1>Hello, world!</h1>
>>    <p>How are you?</p>
>>  </body>
>></html>
>>```
>
> ![[Pasted image 20240902114330.png]] 

# cssom
> [!help] 
> **CSSOM (CSS Object Model)**— это объектная модель CSS, которая представляет собой структуру всех стилей, примененных к элементам на странице. CSSOM создается из всех загруженных и распознанных стилей CSS.
>>```html
>><!DOCTYPE html>
>><html>
>>  <head>
>>    <style>
>>      body { background-color: lightblue; }
>>      h1 { color: navy; }
>>      p { color: red; }
>>    </style>
>>  </head>
>>  <body>
>>    <h1>Hello, world!</h1>
>>    <p>How are you?</p>
>>  </body>
>></html>
>>```


# html
> [!help] 
>**HTML (HyperText Markup Language)** — это язык гипертекстовой разметки, который используется для создания и структурирования веб-страниц. Он позволяет определять, как контент будет отображаться в браузере.
>###### Основные элементы HTML
>> HTML состоит из различных элементов, которые заключены в теги. Вот несколько основных тегов:
>> - ```<html>```: Корневой элемент, который содержит весь HTML-документ.
>> - ```<head>```: Содержит метаданные о документе, такие как `<title>`, `<meta>`, `<link>`.
>> - ```<title>```: Определяет заголовок страницы, который отображается на вкладке браузера.
>> - ```<body>```: Содержит основной контент страницы, такой как текст, изображения, ссылки и другие элементы.
>
> ```html
> <!DOCTYPE html>
> <html>
>  <head>
>    <title>My First Web Page</title>
>  </head>
>  <body>
>    <h1>Hello, world!</h1>
>    <p>How are you?</p>
>  </body>
></html>
>```

# async/defer
> [!help] 
> - Без **async** и **defer**: Скрипты выполняются сразу после загрузки, приостанавливая парсинг HTML.
> - С **async**: Скрипты выполняются сразу после загрузки, но парсинг HTML не останавливается.
> - С **defer**: Скрипты выполняются только после завершения парсинга HTML и создания DOM, перед началом рендеринга 
>> ```ts
>><script src="script.js" async></script>
>>```
>> ```ts
>><script src="script.js" defer></script>
>>```


# preload

> [!help] 
> **Preload** — это атрибут, который позволяет браузеру заранее загружать ресурсы, такие как скрипты, стили, шрифты и изображения, чтобы они были готовы к использованию, когда это потребуется.
> 
> ###### Как работает preload:
>>- **Preload** загружает ресурс в фоновом режиме, не останавливая парсинг HTML.
>> - Ресурс становится доступным, когда браузер доходит до точки, где он нужен, что ускоряет рендеринг страницы.
> 
>  ###### Пример:
>> - ***Шрифты***
>> ```html
>><link rel="preload" href="fonts/myfont.woff2" as="font" type="font/woff2" crossorigin="anonymous">
>>```
>>
>> - ***Скрипты (в комбинации с [defer или async](#async/defer))***
>> ```html
>><link rel="preload" href="script.js" as="script">
>><script src="script.js" defer></script>
>>
>  ###### Преимущества:
>> - Ускоряет загрузку критичных ресурсов.
>> - Уменьшает задержки при рендеринге страницы.
>> - Повышает производительность и улучшает пользовательский опыт.

 
# семантические-тэги
> [!help] 
> **Семантические теги** в [HTML](#html) дают браузеру и разработчикам понимание типа контента. 
>> - `<header>`: Заголовок веб-страницы или раздела.
>>  - `<nav>`: Навигационная ссылка. 
>>  - `<main>`: Основное содержимое веб-страницы. 
>>  - `<article>`: Самостоятельный контент, который имеет смысл вне контекста страницы. 
>>  - `<section>`: Раздел веб-страницы. 
>>  - `<aside>`: Содержимое, относящееся к основному контенту страницы, но которое можно отделить от него. 
>>  - `<footer>`: Подвал веб-страницы или раздела. Использование семантических тегов улучшает доступность сайта, помогает поисковым системам понять структуру контента и упрощает стилизацию страницы.
>
>Использование семантических тегов улучшает доступность сайта, помогает поисковым системам понять структуру контента и упрощает стилизацию страницы.

# babling-capturing
> [!help] 
>> [!quote] 
>> **Bubbling (всплытие)**  - событие распространяется от целевого элемента вверх по DOM-дереву.
>
>> [!quote] 
>> **Capturing (погружение)** - событие сначала обрабатывается на верхнем уровне, затем спускается к целевому элементу.
> ###### Использование в JavaScript
>>> [!info]
>>> **Третий аргумент в addEventListener** - Этот аргумент определяет, будет ли обработчик события вызван на фазе **capturing** (если true) или на фазе **bubbling** (если false или не указан).
>>> ```js
>>>element.addEventListener(event, handler, useCapture)
>>>```
>>>Где:
>>> - `event` - тип события (например, 'click')
>>> - `handler` - функция-обработчик события
>>> - `useCapture` - булево значение, определяющее, будет ли обработчик вызван на фазе capturing (true) или bubbling (false)
>>> 
>>>> [!example] 
>>>> ```html
>>>> <div id="outer">
>>>>   <div id="inner">
>>>>     <button id="button">Нажми меня</button>
>>>>   </div>
>>>> </div>
>>>> <script>
>>>> const outer = document.getElementById('outer');
>>>> const inner = document.getElementById('inner');
>>>> const button = document.getElementById('button');
>>>> outer.addEventListener('click', () => console.log('Outer (bubble)'));
>>>> inner.addEventListener('click', () => console.log('Inner (bubble)'));
>>>> button.addEventListener('click', () => console.log('Button (bubble)'));
>>>> outer.addEventListener('click', () => console.log('Outer (capture)'), true);
>>>> inner.addEventListener('click', () => console.log('Inner (capture)'), true);
>>>> button.addEventListener('click', () => console.log('Button (capture)'), true);
>>>> </script>
>>>
>>>> ###### Результат
>>>>| ***CAPTURE***      | ***BUBBLE***       |
>>>>|--------------------|--------------------|
>>>>| Outer (capture)    | Button (bubble)    |
>>>>| Inner (capture)    | Inner (bubble)     |
>>>>| Button (capture)   | Outer (bubble)     |
>>>> ###### Объяснение
>>>> 1. Сначала событие проходит фазу capturing сверху вниз (от outer к button).
>>>> 2. Затем происходит фаза target (сам клик на кнопке).
>>>> 3. После этого начинается фаза bubbling снизу вверх (от button к outer).
>>> 
>>> ###### Практическое применение в веб-разработке:
>>> 
>>> Перехват событий на ранней стадии:
>>> - Иногда нужно обработать событие до того, как оно достигнет целевого элемента. Например, для логирования или для предотвращения определенных действий.
>>> ```js
>>> document.addEventListener('click', (e) => {
>>>   if (e.target.tagName === 'BUTTON' && e.target.classList.contains('disabled')) {
>>>     e.preventDefault();
>>>     e.stopPropagation();
>>>    console.log('Клик по отключенной кнопке предотвращен');
>>>  }
>>>}, true);
>>>```
>>>Создание кастомных событий с особым поведением:
>>> - Можно создать событие, которое сначала обрабатывается на фазе capturing, а затем на фазе bubbling, что позволяет реализовать сложную логику обработки.
>>> - Оптимизация производительности:
>>> - В некоторых случаях использование capturing может быть более эффективным, особенно если нужно обработать событие только один раз на верхнем уровне DOM.
>>
>>>[!info]
>>> **В React есть onClickCapture**