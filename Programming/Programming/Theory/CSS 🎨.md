# box-sizing
> [!help] 
>
> Свойство `box-sizing` может принимать одно из двух значений – `border-box` или `content-box`. В зависимости от выбранного значения браузер по-разному трактует значение свойств `width/height`.
> > [!quote] 
> **content-box** даёт стандартное поведение свойства `box-sizing`. Если вы выставите элементу ширину `100px`, то ширина его контента будет `100px`, а ширина границ и внутренних отступов при рендере будет добавлена к финальной ширине, делая элемент шире `100px`.
>
> > [!quote] 
> **border-box** говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину `100px`, то эти `100px` будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов.
> 
> ![[Pasted image 20241218155951.png]]

# normalize-и-reset
> [!help] 
> Стили **normalize** и **reset** — это два различных подхода к инициализации стилей браузера, которые помогают обеспечить кросс-браузерную совместимость и предсказуемое поведение CSS.
>
> > [!quote] **Reset CSS**
>**Reset CSS** - стремится устранить все браузерные стили по умолчанию, обнуляя или устанавливая все основные стили (отступы, поля, шрифты и т.д.) до начальных значений. Это позволяет начать с чистого листа и явно задавать стили для каждого элемента.
>
>> [!example] **Reset CSS**
>>```css
>>/* Простой пример Reset CSS */
>>html, body, div, span, applet, object, iframe,
>>h1, h2, h3, h4, h5, h6, p, blockquote, pre,
>>a, abbr, acronym, address, big, cite, code,
>>del, dfn, em, img, ins, kbd, q, s, samp,
>>small, strike, strong, sub, sup, tt, var,
>>b, u, i, center,
>>dl, dt, dd, ol, ul, li,
>>fieldset, form, label, legend,
>>table, caption, tbody, tfoot, thead, tr, th, td,
>>article, aside, canvas, details, embed, 
>>figure, figcaption, footer, header, hgroup, 
>>menu, nav, output, ruby, section, summary,
>>time, mark, audio, video {
>>  margin: 0;
>>  padding: 0;
>>  border: 0;
>>  font-size: 100%;
>>  font: inherit;
>>  vertical-align: baseline;
>>}
>
> > [!quote] **Normalize CSS**
>> **Normalize CSS** - действует немного по-другому: он не обнуляет все стили по умолчанию, а вместо этого старается сделать стили по умолчанию более согласованными и предсказуемыми. Normalize сохраняет полезные браузерные стили по умолчанию и делает их более последовательными между браузерами.
>
>> [!example] **Normalize CSS**
>>```css
>>/* Простой пример Normalize CSS */
>>html {
>>  line-height: 1.15; /* 1 */
>>  -webkit-text-size-adjust: 100%; /* 2 */
>>}
>>
>>body {
>>  margin: 0;
>>}
>>
>>/* Заголовки */
>>h1 {
>>  font-size: 2em;
>>  margin: 0.67em 0;
>>}

# inline/inline-block
> [!help] 
>В CSS разница между `inline` и `inline-block` заключается в их поведении и возможностях стилизации:
>   - **inline**: Элементы с этим значением `display` ведут себя как ***текст***. Они располагаются в одной строке с соседними элементами и ***не допускают изменения размеров (width и height)***. Пример: `<span>`, `<a>`, `<strong>`.
>------
>   - **inline-block**: Работает как `inline`, ***но позволяет задавать размеры (width, height) и применять отступы (margin, padding)***. Это полезно, если нужен элемент, который ведёт себя как текст, но при этом поддерживает стилизацию блочных элементов.
>
>>[!example]
>>```css
>>.inline-example {
>>  display: inline;
>>  width: 100px; /* НЕ сработает */
>>  height: 50px; /* НЕ сработает */
>>}
>>
>>.inline-block-example {
>>  display: inline-block;
>>  width: 100px; /* Сработает */
>>  height: 50px; /* Сработает */
>>}
>>```
>
>Таким образом, `inline-block` даёт больше возможностей по оформлению, сохраняя компактное расположение в строке. Если нужно изменить размер элемента или задать ему отступы, но оставить его в строке — лучше использовать `inline-block`.

# типы-позиционирования
> [!help] 
> 
> 1. **Static** 
> 	   - это стандартное значение, элементы следуют обычному потоку документа. 
> 1. **Relative** 
> 	   - элемент сначала занимает свое обычное место в потоке документа, как если бы у него было значение `static`. Затем, используя свойства `top`, `right`, `bottom` и `left`, вы можете сместить его относительно этого обычного места.
> 1. **Fixed** 
> 	   - Элемент позиционируется относительно окна браузера и остается на месте при прокрутке страницы. Он не перемещается вместе с содержимым страницы.
>  1. **Absolute** 
> 	   -  Элемент позиционируется относительно ближайшего позиционированного родителя (элемент с `position` отличным от `static`). Если такого родителя нет, то относительно окна браузера.
>   1. **Sticky** 
>      - Элемент с `position: sticky` ведет себя как `relative` до тех пор, пока не достигнет заданной позиции при прокрутке. Когда элемент достигает этой позиции, он “прилипает” и ведет себя как `fixed`, оставаясь на месте в пределах своего родительского контейнера.
> 
> 
> ![[Pasted image 20240906111256.png]]
 
# BEM-(Block-Element-Modifier)
> [!help] 
> **BEM (Block, Element, Modifier)** — это методология ***именования*** классов в CSS, которая помогает организовать и масштабировать код, делая его более понятным и поддерживаемым.
>
>> **Основные концепции BEM**:
>> - ***Block (Блок)***:
>>  Независимая сущность, которая может быть использована повторно. Например, `header`, `container`, `menu`.
>>
>> - ***Element (Элемент)***:
>>Часть блока, которая выполняет определённую функцию. Элементы не могут существовать отдельно от блока. Например, `menu__item`, `header__logo`.
>>
>> - ***Modifier (Модификатор)***:
>>Определяет вид или состояние блока или элемента. Модификаторы могут изменять внешний вид, поведение или состояние. Например, `button--primary`, `menu__item--active`.
>
>>[!example]
>>```html
>><div class="menu">
>>  <div class="menu__item menu__item--active">Главная</div>
>>  <div class="menu__item">О нас</div>
>>  <div class="menu__item">Контакты</div>
>></div>

# центрирование-блока
> [!help] 
>  Существует несколько способов центрирования блоков в CSS, и их количество зависит от контекста и требований. Вот основные методы:
> ###### Горизонтальное центрирование с помощью `margin: 0 auto`
> >   ```css
>>    .center {
>>      margin: 0 auto;
>>      width: 50%; /* или другая фиксированная ширина */
>>    }
>>```
>
>  ###### Использование Flexbox
>>    ```css
>>    .container {
>>      display: flex;
>>      justify-content: center; /* горизонтальное центрирование */
>>      align-items: center; /* вертикальное центрирование */
>>    }
>>    .center {
>>      width: 50%; /* или другая фиксированная ширина */
>>   }
>>    ```   
>
>###### Использование Grid Layout    
>>    ```css
>>   .container {
>>      display: grid;
>>      place-items: center; /* центрирование по горизонтали и вертикали */
>>    }
>>    .center {
>>      width: 50%; /* или другая фиксированная ширина */
>>    }
>>    ```
>
>###### Абсолютное позиционирование
>>    ```css
>>   .container {
>>      position: relative;
>>      height: 100vh; /* высота контейнера */
>>    }
>>    .center {
>>      position: absolute;
>>      top: 50%;
>>      left: 50%;
>>      transform: translate(-50%, -50%);
>>    }
>>    ```
>>    Свойство `transform: translate(-50%, -50%)` используется для центрирования элемента, который имеет абсолютное позиционирование.
>>- **`translate(-50%, -50%)`**:
>>    - `translate` перемещает элемент по осям X и Y.
>>    - Значения `-50%` означают, что элемент будет смещен на 50% своей ширины влево и на 50% своей высоты вверх.
>>Когда вы используете абсолютное позиционирование, элемент обычно позиционируется относительно ближайшего позиционированного предка (контейнера).
>>    
>>    

# padding-margin
> [!help] 
> > [!quote] 
>  **Margin** - это внешний отступ вокруг элемента. Он находится за пределами границы элемента и используется для создания пространства между различными элементами на странице.
>  
> > [!quote] 
>  **Padding** - это внутренний отступ вокруг содержимого элемента. Он находится внутри границы элемента и используется для создания пространства между границей и содержимым элемента. 
>  
> > [!info]
> >   Важно помнить, что изменение padding увеличивает общий размер элемента, в то время как изменение margin не влияет на общий размер элемента, но меняет его положение на странице.
> 

# блочные-строчные-элементы
> [!help] 
> 
> В CSS элементы делятся на два основных типа: **блочные** и **строчные**.
>###### Блочные элементы (block elements)
>>- **Начинаются с новой строки**: Каждый блочный элемент занимает всю доступную ширину контейнера.
>>- **Ширина и высота**: Можно задавать свойства `width` и `height`.
>>- **Отступы и рамки**: Внешние и внутренние отступы, а также рамки, отодвигают другие элементы.
>>- **Примеры**: `<div>`, `<p>`, `<h1>`, `<ul>`, `<ol>`.
>###### Строчные элементы (inline elements)
>>- **Не начинаются с новой строки**: Строчные элементы располагаются в одной строке с другими элементами.
>>- **Ширина и высота**: Свойства `width` и `height` не применяются.
>>- **Отступы и рамки**: Вертикальные отступы и рамки не отодвигают другие элементы, а горизонтальные — отодвигают.
>>- **Примеры**: `<span>`, `<a>`, `<em>`, `<strong>`, `<img>`.

# селекторы-css
> [!help] 
> > [!quote] 
> **Селекторы CSS** используются для выбора элементов, к которым применяются стили.
> ###### Основные типы селекторов
>>1. **Тип элемента**: Применяет стили ко всем элементам указанного типа. Например, `p{ color: red;}` применит стиль ко всем параграфам.   
>>2. **Класс**: Применяет стили к элементам с определённым классом. Например, `.my-class{ color: blue;}` применит стиль к элементам с классом `my-class`.    
>>3. **ID**: Применяет стили к элементу с определённым ID. Например, `#my-id{ color: green; }` применит стиль к элементу с ID `my-id`.    
>>4. **Чилдрены**: Применяет стили к чилдренам элемента. Например, `div p{ color: purple; }` применит стиль ко всем параграфам внутри `div`.   
>>5. **Псевдоклассы**: Применяют стили к элементам в определённом состоянии. Например, `a:hover{ color: orange; }` применит стиль к ссылкам при наведении курсора.  
>>6. **Атрибутные селекторы**: Применяют стили к элементам с определёнными атрибутами. Например, `input[type="text"]{ color: black; }` применит стиль ко всем текстовым полям ввода.   
>>7. **Групповые селекторы**: Позволяют применять один и тот же стиль к нескольким элементам. Например, `h1, h2, h3{ color: navy; }` применит стиль ко всем заголовкам первого, второго и третьего уровней.   
>>8. **Псевдоэлементы**: Применяют стили к определённым частям элемента. Например, `p::first-line{ font-weight: bold; }` применит стиль к первой строке каждого параграфа.  
>>9. **Комбинаторы**: Используются для выбора элементов на основе их отношений в дереве DOM. Например, `ul > li { color: brown; }` применит стиль ко всем элементам `li`, которые являются непосредственными чилдренами `ul`.
>
> > [!hint] 
>>1. **Структура селекторов**
>> - Вложенные элементы: `nav menu li` — ***стиль для вложенных элементов.***
>>  - Дочерние элементы: `.icons > div` — ***дочерние элементы первого уровня.***
>>  - Соседние элементы: `.icons img + h4` — ***элементы, расположенные рядом.***
>>2. **Атрибутные селекторы**
>>   - `img[src^='img/']` — элементы, где `src` ***начинается*** с указанного значения.
>>  - `img[src$='.png']` — элементы, где `src` з***аканчивается*** на указанное значение.
>>   - `a[href*='#']` — элементы, у которых `href` ***содержит*** определённое значение.
> 
>  
# псевдоклассы-псевдоэлементы
> [!help] 
> 
> **Псевдоклассы в CSS** — это специальные ключевые слова, которые добавляются к селектору и позволяют применять стили к элементам в зависимости от их состояния, положения в документе или взаимодействия с пользователем. Они помогают создавать более динамичные и интерактивные интерфейсы без использования JavaScript.
> ###### Псевдоклассы
>>- **:hover** — применяется, когда курсор мыши находится над элементом.
>>- **:active** — применяется в момент нажатия на элемент.
>>- **:focus** — применяется, когда элемент получает фокус ввода.
>>- **:visited** — применяется к посещенным ссылкам.
>>- **:link** — применяется к непосещенным ссылкам.
>>- **:first-child** — применяется к первому дочернему элементу родителя.
>>- **:last-child** — применяется к последнему дочернему элементу родителя.
>>- **:nth-child(n)** — применяется к n-му дочернему элементу родителя.
>>- **:not(selector)** — применяется ко всем элементам, кроме указанного селектора.
>>- **:empty** — применяется к элементам, которые не содержат дочерних элементов или текста.
>###### Псевдоэлементы
>>
>>- **::before** — создает псевдоэлемент, который является первым дочерним элементом выбранного элемента. Обычно используется для добавления декоративного контента.
>>- **::after** — создает псевдоэлемент, который является последним дочерним элементом выбранного элемента. Также обычно используется для добавления декоративного контента.

# приортер-по-стилям
> [!help] 
> 
> Приоритеты стилей в CSS, также известные как специфичность (specificity), определяют, какие правила CSS будут применены к элементу в случае конфликта. Вот краткое описание приоритетов от высшего к низшему:
>1. **!important**  
>       Самый высокий приоритет. Переопределяет все другие объявления.  
>       Пример: `color: red !important;`
>2. Встроенные стили (**Inline styles**)  
>       Стили, определенные непосредственно в HTML-атрибуте style.  
>       Пример: `<div style="color: blue;">...</div>`    
>3. **ID селекторы**  
>       Селекторы, использующие ID элемента.  
 >      Пример: `#myElement { color: green; }`    
>4. **Классы, атрибуты и псевдоклассы**  
>       Селекторы, использующие классы, атрибуты или псевдоклассы.  
>       Примеры:  
 >      - `.myClass { color: yellow; }`
>       - `[type="text"] { color: gray; }`
>       - `:hover { color: orange; }`
>5. **Элементы и псевдоэлементы**  
>       Селекторы, использующие имена тегов или псевдоэлементы.  
>       Примеры:   
>       - `p { color: purple; }`
>       - `::before { content: "Hi!"; }`
>6. **Универсальный селектор**  
>       Селектор, который применяется ко всем элементам.  
>       Пример: `* { color: black; }`    
>7. **Наследуемые стили**  
>       Стили, которые наследуются от родительских элементов.
> ###### Дополнительные правила:
>>- Если специфичность одинакова, применяется правило, определенное позже.
>>- Каскадность: стили из более поздних таблиц стилей имеют приоритет над более ранними.
>>- Стили, определенные ближе к элементу, имеют больший приоритет.
>>Пример расчета специфичности:
>>- `#header .nav li:hover` (1,0,2,1)
>>- `body #content .data img:hover` (1,1,2,1)
>>В этом примере второй селектор имеет более высокую специфичность из-за дополнительного ID селектора.
>
# схлопывание(margin-collapsing)
> [!help] 
> > [!quote] 
> **Схлопывание отступов (margin collapsing)** - это поведение в CSS, когда вертикальные отступы (`margins`) двух элементов сливаются в один. Это происходит, когда верхний отступ одного элемента встречается с нижним отступом другого элемента. 
> ###### Почему это происходит:
>>1. Это поведение было введено для более естественного распределения пространства между параграфами и другими блочными элементами.
>>2. Оно помогает избежать чрезмерных пробелов при вложенности элементов.
>###### Когда происходит схлопывание:
>>1. Между соседними блочными элементами.
>>2. Между родительским и первым/последним дочерним элементом, если нет `padding`, `border` или `inline content`, разделяющих их `margins`.
>>3. На пустых блоках, где верхний и нижний `margin` соприкасаются.
>###### Пример:
>> ```html
>> <style>
>>  .block1 { margin-bottom: 20px; }
>>  .block2 { margin-top: 30px; }
>> </style>
>> <div class="block1">Block 1</div>
>> <div class="block2">Block 2</div>
>>```
>>>Здесь отступ между блоками будет ***30px***, а не ***50px***.
>###### Как решить или предотвратить схлопывание:
>>1. Использовать `padding` вместо `margin`.
>>2. Добавить `border` или `padding` к родительскому элементу.
>>3. Установить `overflow: auto` или `overflow: hidden` для родительского элемента.
>>4. Использовать `display: flex` или `display: grid` для родительского контейнера.
>>5. Применить `display: inline-block` к элементам.
>>6. Добавить пустой элемент с `height: 1px` между элементами.
>###### Пример решения:
>>```html
>><style>
>>  .parent {
>>    overflow: auto;
>>    /* или */
>>    /* display: flex; */
>>    /* flex-direction: column; */
>>  }
>>  .child {
>>    margin-top: 20px;
>>    margin-bottom: 20px;
>>  }
>></style>
>><div class="parent">
>>  <div class="child">Child 1</div>
>>  <div class="child">Child 2</div>
>></div>
>>```
>###### Важно помнить:
>>- Схлопывание работает только для вертикальных margins.
>>- Горизонтальные margins всегда суммируются.
>>- Отрицательные margins могут усложнить поведение схлопывания.
> 

 