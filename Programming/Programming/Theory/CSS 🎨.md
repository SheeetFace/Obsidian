# типы-позиционирования
> [!help] 
> 
> 1. **Static** 
> 	   - это стандартное значение, элементы следуют обычному потоку документа. 
> 1. **Relative** 
> 	   - элемент сначала занимает свое обычное место в потоке документа, как если бы у него было значение `static`. Затем, используя свойства `top`, `right`, `bottom` и `left`, вы можете сместить его относительно этого обычного места.
> 1. **Fixed** 
> 	   - Элемент позиционируется относительно окна браузера и остается на месте при прокрутке страницы. Он не перемещается вместе с содержимым страницы.
>  1. **Absolute** 
> 	   -  Элемент позиционируется относительно ближайшего позиционированного родителя (элемент с `position` отличным от `static`). Если такого родителя нет, то относительно окна браузера.
>   1. **Sticky** 
>      - Элемент с `position: sticky` ведет себя как `relative` до тех пор, пока не достигнет заданной позиции при прокрутке. Когда элемент достигает этой позиции, он “прилипает” и ведет себя как `fixed`, оставаясь на месте в пределах своего родительского контейнера.
> 
> 
> ![[Pasted image 20240906111256.png]]
 
# центрирование-блока
> [!help] 
>  Существует несколько способов центрирования блоков в CSS, и их количество зависит от контекста и требований. Вот основные методы:
> ###### Горизонтальное центрирование с помощью `margin: 0 auto`
> >   ```css
>>    .center {
>>      margin: 0 auto;
>>      width: 50%; /* или другая фиксированная ширина */
>>    }
>>```
>
>  ###### Использование Flexbox
>>    ```css
>>    .container {
>>      display: flex;
>>      justify-content: center; /* горизонтальное центрирование */
>>      align-items: center; /* вертикальное центрирование */
>>    }
>>    .center {
>>      width: 50%; /* или другая фиксированная ширина */
>>   }
>>    ```   
>
>###### Использование Grid Layout    
>>    ```css
>>   .container {
>>      display: grid;
>>      place-items: center; /* центрирование по горизонтали и вертикали */
>>    }
>>    .center {
>>      width: 50%; /* или другая фиксированная ширина */
>>    }
>>    ```
>
>###### Абсолютное позиционирование
>>    ```css
>>   .container {
>>      position: relative;
>>      height: 100vh; /* высота контейнера */
>>    }
>>    .center {
>>      position: absolute;
>>      top: 50%;
>>      left: 50%;
>>      transform: translate(-50%, -50%);
>>    }
>>    ```
>>    Свойство `transform: translate(-50%, -50%)` используется для центрирования элемента, который имеет абсолютное позиционирование.
>>- **`translate(-50%, -50%)`**:
>>    - `translate` перемещает элемент по осям X и Y.
>>    - Значения `-50%` означают, что элемент будет смещен на 50% своей ширины влево и на 50% своей высоты вверх.
>>Когда вы используете абсолютное позиционирование, элемент обычно позиционируется относительно ближайшего позиционированного предка (контейнера).
>>    
>>    

# padding-margin
> [!help] 
> > [!quote] 
>  **Margin** - это внешний отступ вокруг элемента. Он находится за пределами границы элемента и используется для создания пространства между различными элементами на странице.
>  
> > [!quote] 
>  **Padding** - это внутренний отступ вокруг содержимого элемента. Он находится внутри границы элемента и используется для создания пространства между границей и содержимым элемента. 
>  
> > [!info]
> >   Важно помнить, что изменение padding увеличивает общий размер элемента, в то время как изменение margin не влияет на общий размер элемента, но меняет его положение на странице.
> 

# блочные-строчные-элементы
> [!help] 
> 
> В CSS элементы делятся на два основных типа: **блочные** и **строчные**.
>###### Блочные элементы (block elements)
>>- **Начинаются с новой строки**: Каждый блочный элемент занимает всю доступную ширину контейнера.
>>- **Ширина и высота**: Можно задавать свойства `width` и `height`.
>>- **Отступы и рамки**: Внешние и внутренние отступы, а также рамки, отодвигают другие элементы.
>>- **Примеры**: `<div>`, `<p>`, `<h1>`, `<ul>`, `<ol>`.
>###### Строчные элементы (inline elements)
>>- **Не начинаются с новой строки**: Строчные элементы располагаются в одной строке с другими элементами.
>>- **Ширина и высота**: Свойства `width` и `height` не применяются.
>>- **Отступы и рамки**: Вертикальные отступы и рамки не отодвигают другие элементы, а горизонтальные — отодвигают.
>>- **Примеры**: `<span>`, `<a>`, `<em>`, `<strong>`, `<img>`.

# селекторы-css
> [!help] 
> > [!quote] 
> **Селекторы CSS** используются для выбора элементов, к которым применяются стили.
> ###### Основные типы селекторов
>>1. **Тип элемента**: Применяет стили ко всем элементам указанного типа. Например, `p{ color: red;}` применит стиль ко всем параграфам.   
>>2. **Класс**: Применяет стили к элементам с определённым классом. Например, `.my-class{ color: blue;}` применит стиль к элементам с классом `my-class`.    
>>3. **ID**: Применяет стили к элементу с определённым ID. Например, `#my-id{ color: green; }` применит стиль к элементу с ID `my-id`.    
>>4. **Чилдрены**: Применяет стили к чилдренам элемента. Например, `div p{ color: purple; }` применит стиль ко всем параграфам внутри `div`.   
>>5. **Псевдоклассы**: Применяют стили к элементам в определённом состоянии. Например, `a:hover{ color: orange; }` применит стиль к ссылкам при наведении курсора.  
>>6. **Атрибутные селекторы**: Применяют стили к элементам с определёнными атрибутами. Например, `input[type="text"]{ color: black; }` применит стиль ко всем текстовым полям ввода.   
>>7. **Групповые селекторы**: Позволяют применять один и тот же стиль к нескольким элементам. Например, `h1, h2, h3{ color: navy; }` применит стиль ко всем заголовкам первого, второго и третьего уровней.   
>>8. **Псевдоэлементы**: Применяют стили к определённым частям элемента. Например, `p::first-line{ font-weight: bold; }` применит стиль к первой строке каждого параграфа.  
>>9. **Комбинаторы**: Используются для выбора элементов на основе их отношений в дереве DOM. Например, `ul > li { color: brown; }` применит стиль ко всем элементам `li`, которые являются непосредственными чилдренами `ul`.
> 
> 
>  
# псевдоклассы-псевдоэлементы
> [!help] 
> 
> **Псевдоклассы в CSS** — это специальные ключевые слова, которые добавляются к селектору и позволяют применять стили к элементам в зависимости от их состояния, положения в документе или взаимодействия с пользователем. Они помогают создавать более динамичные и интерактивные интерфейсы без использования JavaScript.
> ###### Псевдоклассы
>>- **:hover** — применяется, когда курсор мыши находится над элементом.
>>- **:active** — применяется в момент нажатия на элемент.
>>- **:focus** — применяется, когда элемент получает фокус ввода.
>>- **:visited** — применяется к посещенным ссылкам.
>>- **:link** — применяется к непосещенным ссылкам.
>>- **:first-child** — применяется к первому дочернему элементу родителя.
>>- **:last-child** — применяется к последнему дочернему элементу родителя.
>>- **:nth-child(n)** — применяется к n-му дочернему элементу родителя.
>>- **:not(selector)** — применяется ко всем элементам, кроме указанного селектора.
>>- **:empty** — применяется к элементам, которые не содержат дочерних элементов или текста.
>###### Псевдоэлементы
>>
>>- **::before** — создает псевдоэлемент, который является первым дочерним элементом выбранного элемента. Обычно используется для добавления декоративного контента.
>>- **::after** — создает псевдоэлемент, который является последним дочерним элементом выбранного элемента. Также обычно используется для добавления декоративного контента.

# приортер-по-стилям
> [!help] 
> 
> Приоритеты стилей в CSS, также известные как специфичность (specificity), определяют, какие правила CSS будут применены к элементу в случае конфликта. Вот краткое описание приоритетов от высшего к низшему:
>1. **!important**  
>       Самый высокий приоритет. Переопределяет все другие объявления.  
>       Пример: `color: red !important;`
>2. Встроенные стили (**Inline styles**)  
>       Стили, определенные непосредственно в HTML-атрибуте style.  
>       Пример: `<div style="color: blue;">...</div>`    
>3. **ID селекторы**  
>       Селекторы, использующие ID элемента.  
 >      Пример: `#myElement { color: green; }`    
>4. **Классы, атрибуты и псевдоклассы**  
>       Селекторы, использующие классы, атрибуты или псевдоклассы.  
>       Примеры:  
 >      - `.myClass { color: yellow; }`
>       - `[type="text"] { color: gray; }`
>       - `:hover { color: orange; }`
>5. **Элементы и псевдоэлементы**  
>       Селекторы, использующие имена тегов или псевдоэлементы.  
>       Примеры:   
>       - `p { color: purple; }`
>       - `::before { content: "Hi!"; }`
>6. **Универсальный селектор**  
>       Селектор, который применяется ко всем элементам.  
>       Пример: `* { color: black; }`    
>7. **Наследуемые стили**  
>       Стили, которые наследуются от родительских элементов.
> ###### Дополнительные правила:
>>- Если специфичность одинакова, применяется правило, определенное позже.
>>- Каскадность: стили из более поздних таблиц стилей имеют приоритет над более ранними.
>>- Стили, определенные ближе к элементу, имеют больший приоритет.
>>Пример расчета специфичности:
>>- `#header .nav li:hover` (1,0,2,1)
>>- `body #content .data img:hover` (1,1,2,1)
>>В этом примере второй селектор имеет более высокую специфичность из-за дополнительного ID селектора.
>
# схлопывание(margin-collapsing)
> [!help] 
> > [!quote] 
> **Схлопывание отступов (margin collapsing)** - это поведение в CSS, когда вертикальные отступы (`margins`) двух элементов сливаются в один. Это происходит, когда верхний отступ одного элемента встречается с нижним отступом другого элемента. 
> ###### Почему это происходит:
>>1. Это поведение было введено для более естественного распределения пространства между параграфами и другими блочными элементами.
>>2. Оно помогает избежать чрезмерных пробелов при вложенности элементов.
>###### Когда происходит схлопывание:
>>1. Между соседними блочными элементами.
>>2. Между родительским и первым/последним дочерним элементом, если нет `padding`, `border` или `inline content`, разделяющих их `margins`.
>>3. На пустых блоках, где верхний и нижний `margin` соприкасаются.
>###### Пример:
>> ```html
>> <style>
>>  .block1 { margin-bottom: 20px; }
>>  .block2 { margin-top: 30px; }
>> </style>
>> <div class="block1">Block 1</div>
>> <div class="block2">Block 2</div>
>>```
>>>Здесь отступ между блоками будет ***30px***, а не ***50px***.
>###### Как решить или предотвратить схлопывание:
>>1. Использовать `padding` вместо `margin`.
>>2. Добавить `border` или `padding` к родительскому элементу.
>>3. Установить `overflow: auto` или `overflow: hidden` для родительского элемента.
>>4. Использовать `display: flex` или `display: grid` для родительского контейнера.
>>5. Применить `display: inline-block` к элементам.
>>6. Добавить пустой элемент с `height: 1px` между элементами.
>###### Пример решения:
>>```html
>><style>
>>  .parent {
>>    overflow: auto;
>>    /* или */
>>    /* display: flex; */
>>    /* flex-direction: column; */
>>  }
>>  .child {
>>    margin-top: 20px;
>>    margin-bottom: 20px;
>>  }
>></style>
>><div class="parent">
>>  <div class="child">Child 1</div>
>>  <div class="child">Child 2</div>
>></div>
>>```
>###### Важно помнить:
>>- Схлопывание работает только для вертикальных margins.
>>- Горизонтальные margins всегда суммируются.
>>- Отрицательные margins могут усложнить поведение схлопывания.
> 

 