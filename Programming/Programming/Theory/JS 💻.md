# JS
> [!help] 
> 
>JavaScript - это:
>1. **Высокоуровневый язык программирования  **  
>    - Абстрагирован от машинного кода, более близок к человеческому языку.
>      > [!info]-
>      > JavaScript можно использовать для иллюстрации принципа ***абстракции*** в  ([[ООП]]). Абстракция позволяет нам работать с объектами через их интерфейсы, скрывая внутреннюю реализацию и сложность.
>    - Обеспечивает автоматическое управление памятью (сборка мусора).
>2. **Динамически типизируемый **   
>    - Типы переменных определяются во время выполнения.
>    - Переменная может хранить значения разных типов в разное время.
>3. **Слабо типизированный**    
>    - Допускает неявное приведение типов.
>4. **Интерпретируемый**    
>    - Код выполняется построчно без предварительной компиляции.
>   > [!info]- 
>   >###### Построчное выполнение:
>   >   - Интерпретатор проходит по коду один раз, выполняя каждую инструкцию по порядку.
>   >###### Процесс выполнения:
>   >   - Код загружается и анализируется (парсится).
>   >   - Затем он выполняется сверху вниз, инструкция за инструкцией.
>   >   - После выполнения всех инструкций программа завершается, если нет бесконечных циклов или событийных слушателей.
>   >###### Контекст веб-страницы:
>   >   - В браузере JavaScript не "крутится" постоянно после загрузки страницы.
>   >   - Вместо этого, после выполнения начального кода, движок JavaScript ожидает событий (клики, таймеры и т.д.).
>   >###### Событийный цикл ([Event Loop](#event-loop)):
>   >   - JavaScript использует событийную модель.
>   >   - После выполнения начального кода, движок входит в состояние ожидания событий.
>   >   - Когда происходит событие, соответствующий обработчик выполняется.
>   >###### Память и выполнение:
>   >   - Интерпретатор не "запоминает" код в том смысле, в котором это делает компилятор.
>   >   - Однако, современные движки JavaScript (как V8) могут кэшировать результаты парсинга и даже компилировать часто используемый код (JIT-компиляция).
>   >###### Глобальный контекст:
>   >   - Глобальные переменные и функции остаются в памяти, пока страница открыта.
>   >   - Это позволяет обращаться к ним из обработчиков событий в любое время.
>    - Современные движки JS используют JIT-компиляцию для оптимизации производительности.
>   > [!info]- 
>   >JIT (Just-In-Time) подход позволяет JavaScript в Chrome быстро начинать выполнение (благодаря интерпретации) и достигать высокой производительности для критических участков кода (благодаря оптимизирующей компиляции).
>   > **JIT (Just-In-Time)** компиляция в V8 -  включает несколько уровней оптимизации. Вот как это работает в общих чертах:
>   >1. ***Интерпретация***:   
>   >    - Сначала весь код интерпретируется построчно интерпретатором Ignition.
>   >2. ***Профилирование***:    
>   >    - Во время выполнения V8 собирает информацию о том, как часто выполняются различные части кода и какие типы данных используются.
>   >3. ***Базовая JIT-компиляция***:    
>   >    - Часто выполняемые функции компилируются в машинный код компилятором TurboFan.
>   >    - Этот код быстрее интерпретируемого, но еще не полностью оптимизирован.
>   >4. ***Оптимизирующая компиляция***:    
>   >    - Для "горячего" кода (очень часто выполняемого) применяется агрессивная оптимизация.
>   >   - Здесь используется собранная информация о типах и поведении кода для создания высокооптимизированного машинного кода.
>   >5. ***Деоптимизация***:   
>   >    - Если предположения, сделанные при оптимизации, оказываются неверными (например, тип переменной изменился), код "деоптимизируется" и возвращается к менее оптимизированной версии или к интерпретации.
>   >6. ***Адаптивная оптимизация***:    
>   >    - V8 продолжает мониторить выполнение и может повторно оптимизировать код, если паттерны использования изменяются.
>   > ###### Ключевые моменты:
>   >>- Не весь код компилируется. Редко используемый код может остаться интерпретируемым.
>   >>- Компиляция происходит параллельно с выполнением программы.
>   >>- Уровень оптимизации зависит от частоты использования кода и стабильности типов.
>   >>- V8 балансирует между скоростью запуска (интерпретация) и скоростью выполнения (компиляция).
>  
>5. **Встраиваемый**    
>    - Может быть встроен в веб-браузеры и другие хост-среды (например, Node.js).
>    - Не имеет собственного ввода/вывода, полагается на хост-среду для этих функций.
>6. **Мультипарадигменный**   
>    - Поддерживает процедурное, объектно-ориентированное и функциональное программирование.
>      > [!info]- 
>      > ###### Основные парадигмы программирования:
>      >>1. ***Императивное программирование***
>      >>    - Процедурное программирование
>      >>    - Объектно-ориентированное программирование ([[ООП]])
>      >>2. ***Декларативное программирование ***   
>      >>    - Функциональное программирование
>      >>    - Логическое программирование
>      >>3. ***Структурное программирование***    
>      >>4. ***Событийно-ориентированное программирование***  
>      >>5. ***Аспектно-ориентированное программирование***    
>      >>6. ***Прототипно-ориентированное программирование***    
>      >>7. ***Компонентно-ориентированное программирование***    
>      >>8. ***Параллельное программирование***
>      >>9. ***Реактивное программирование***   
>      > ###### Парадигмы, которые хорошо подходят для JavaScript и широко в нем используются:
>      >>1. ***Процедурное программирование***:  
>      >>    JavaScript позволяет писать последовательные инструкции и организовывать код в функции.   
>      >>    ```js
>      >>    function calculateArea(width, height) {
>      >>        return width * height;
>      >>    }
>      >>      
>      >> 2. ***Объектно-ориентированное программирование***:  
>      >>    JavaScript поддерживает ООП как через прототипы, так и через классы (с ES6).  
>      >>    ```js
>      >>    class Rectangle {
>      >>        constructor(width, height) {
>      >>           this.width = width;
>      >>            this.height = height;
>      >>        }
>      >>        
>      >>        getArea() {
>      >>            return this.width * this.height;
>      >>        }
>      >>    }
>      >>    ```   
>      >>3. ***Функциональное программирование***:  
>      >>    JavaScript поддерживает функции первого класса, замыкания и другие функциональные концепции.    
>      >>    ```js
>      >>   const multiply = (a, b) => a * b;
>      >>    const numbers = [1, 2, 3, 4, 5];
>      >>    const doubled = numbers.map(n => n * 2);
>      >>    ```    
>      >>4. ***Прототипно-ориентированное программирование***:  
>      >>    Это основной механизм наследования в JavaScript.   
>      >>    ```js
>      >>    function Animal(name) {
>      >>        this.name = name;
>      >>    }
>      >>    Animal.prototype.speak = function() {
>      >>        console.log(this.name + ' makes a noise.');
>      >>    };
>      >>    ```
>      >>   
>      >>5. ***Событийно-ориентированное программирование***:  
>      >>    Широко используется в JavaScript, особенно в веб-разработке.
>      >>    ```
>      >>    document.getElementById('myButton').addEventListener('click', function() {
>      >>        console.log('Button clicked!');
>      >>    });
>      >>    ```  
>      >>6. ***Компонентно-ориентированное программирование***:  
>      >>    Популярно в современных фреймворках, таких как React, Vue, Angular.
>      >>    ```ts
>      >>   // Пример React-компонента
>      >>    function Welcome(props) {
>      >>        return <h1>Hello, {props.name}</h1>;
>      >>    }
>      >>    ```   
>      >>7. ***Реактивное программирование***:  
>      >>    Поддерживается через библиотеки, такие как RxJS.
>      >>    ```js
>      >>    // Пример с использованием RxJS
>      >>    import { fromEvent } from 'rxjs';
>      >>    import { map } from 'rxjs/operators';
>      >>    
>      >>    const clicks = fromEvent(document, 'click');
>      >>    const positions = clicks.pipe(map(ev => ev.clientX));
>      >>    positions.subscribe(x => console.log(x));
>      >>    ```   
>      >>8. ***Асинхронное программирование***:  
>      >>    JavaScript отлично поддерживает асинхронное программирование через callbacks, promises и async/await.
>      >>    ```js
>      >>    async function fetchData() {
>      >>       try {
>      >>            const response = await fetch('https://api.example.com/data');
>      >>            const data = await response.json();
>      >>            console.log(data);
>      >>        } catch (error) {
>      >>            console.error('Fetching error:', error);
>      >>        }
>      >>    }
>      >>    ```
>      >> ###### Заключение:  
>      >>>JavaScript действительно является мультипарадигменным языком, поддерживающим множество различных подходов к программированию. Это дает разработчикам большую гибкость в выборе наиболее подходящего стиля для конкретной задачи или проекта. Наиболее часто в JavaScript используются процедурное, объектно-ориентированное и функциональное программирование, но язык также хорошо поддерживает событийно-ориентированное, компонентно-ориентированное и реактивное программирование. Выбор парадигмы часто зависит от конкретных требований проекта, личных предпочтений разработчика и используемых фреймворков или библиотек.
>      > 
>      > 
>  
>7. **Прототипно-ориентированный**    
>    - Использует прототипы для наследования, в отличие от классического [[ООП]].
>8. **Однопоточный с асинхронностью**    
>    - Имеет однопоточную модель выполнения.
>    - Поддерживает асинхронное программирование через callbacks, Promises и async/await.
>9. **Кроссплатформенный**   
>    - Работает на различных платформах и устройствах.
>10. **С поддержкой функций первого класса**    
>       - Функции могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
>       - 

# типы-данных
> [!help] 
> В JavaScript есть **8** основных типов данных:
>1. **Number** (число)
>    - Включает целые числа и числа с плавающей точкой.
>    - Пример: 42, 3.14
>2. **String** (строка)    
>    - Текстовые данные.
>    - Пример: "Hello", 'World'
>3. **Boolean** (логический тип)    
>    - true или false
>4. **Undefined**    
>    - Представляет переменную, которой не присвоено значение.
>    - ***typeof undefined*** возвращает ***"undefined"***
>5. **Null**   
>    - Представляет намеренное отсутствие какого-либо объектного значения.
>    - В отличие от undefined, null всегда присваивается намеренно.
>    - null используется для явного указания на отсутствие значения или "пустоту".
>    - ***typeof null*** возвращает ***"object"***
>6. **Object** (объект)    
>    - Коллекция свойств.
>    - Пример: {name: "John", age: 30}
>7. **Symbol** (символ)    
>    - Уникальный идентификатор.
>    - Введен в ECMAScript 6.
>8. **BigInt**    
>    - Для работы с целыми числами произвольной длины.
>    - Введен в ECMAScript 2020.
>    - Пример: 1234567890123456789012345678901234567890n
> ###### Важные замечания:
>>1. **Массивы и функции**:    
>>    - Технически, массивы (Array) и функции (Function) являются подтипами Object. Но их часто рассматривают как отдельные типы из-за их особого поведения.
>>2. **Примитивные типы**:    
>>    - Number, String, Boolean, Undefined, Null, Symbol и BigInt считаются примитивными типами.
>>    - Object - это непримитивный тип.
>>3. **Специальные объекты**:    
>>    - Date, RegExp, Error и другие встроенные объекты часто упоминаются при обсуждении типов данных, но они являются подтипами Object.
>>4. **typeof оператор**:    
>>    - Оператор typeof может возвращать следующие строки: "number", "string", "boolean", "undefined", "object", "function", "symbol", "bigint".
>>    - Обратите внимание, что typeof null возвращает "object", что считается исторической ошибкой в языке.
>  

# var-let-const
> [!help] 
> 1. **var**:   
>    - [Функциональная область видимости](#области-видимости) 
>         - если объявлена вне функции, то имеет [глобальную область видимости](#области-видимости).
>    - [Поднятие (hoisting)](#поднятие(hosting)) `var` поднимается и инициализируется значением undefined
>    - Можно переопределять
>    - Существует с начала JavaScript
>2. **let**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (точнее, есть "временная мертвая зона"), поднимаются, но не инициализируются
>    - Можно переопределять
>    - Введено в ES6 (2015)
>3. **const**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (как и `let`), поднимаются, но не инициализируются
>    - Нельзя переопределять (но можно изменять содержимое объектов)
>    - Введено в ES6 (2015)
>  
>  > [!example] 
>   >> Если `var` объявлена вне функции, она становится глобальной переменной и свойством глобального объекта (`window` в браузере).
>   >> ```js
>   >>var globalVar = "I'm global";
>   >>console.log(window.globalVar); // "I'm global" (в браузере)
>   >>console.log(globalVar);        // "I'm global" (в браузере)
>   >>```
>   >>Переменная `globalVar`, объявленная с помощью `var`, становится как глобальной переменной, так и свойством объекта `window`. Поэтому мы можем обращаться к ней обоими способами.
>   > ---
>   >>Если `let` или `const` объявлены вне любого блока (в глобальной области), они становятся глобальными переменными, но не становятся свойствами глобального объекта.
>   >> ```js
>   >>let globalLet = "I'm global";
>   >>const globalConst = "I'm also global";
>   >>console.log(window.globalLet);    // undefined (в браузере)
>   >>console.log(window.globalConst);  // undefined (в браузере)
>   >>console.log(globalLet);    // "I'm global" (в браузере)
>   >>console.log(globalConst);  // "I'm also global" (в браузере)
>   >>```
>   >> Переменные `globalLet` и `globalConst`, хотя и являются глобальными (доступны во всем скрипте), не становятся свойствами объекта `window`. Поэтому мы можем обращаться к ним напрямую, но не через window.
>
>  > [!info] 
>> Теоретические причины, по которым var может быть быстрее:
>>1. Отсутствие проверки временной мертвой зоны (TDZ):    
>>    - let и const имеют временную мертвую зону, var - нет.
>>    - Движок JS должен проверять, не находится ли переменная в TDZ при каждом обращении к ней.
>>2. Более простая область видимости:    
>>    - var имеет функциональную область видимости.
>>    - let и const имеют блочную область видимости, что может требовать более сложной логики для отслеживания.
>>3. Поднятие (hoisting):   
>>    - var поднимается и инициализируется значением undefined.
>>    - let и const поднимаются, но не инициализируются, что требует дополнительных проверок. 
>>      
# области-видимости

> [!help] 
>> [!quote] 
>>  - **Глобальная область видимости** - Это самый внешний уровень области видимости. Переменные, объявленные здесь, доступны во всем скрипте.
>
>> [!quote] 
>>  - **Функциональная область видимости** -  Переменные, объявленные внутри функции, доступны только внутри этой функции.
>
>> [!quote] 
>>  - **Блочная область видимости** - Переменные доступны только внутри блока, где они объявлены.
>  
# поднятие(hosting)
> [!help] 
> > [!quote] 
> **Hoisting** (поднятие) — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их [области видимости](#области-видимости) во время выполнения кода. Это позволяет использовать переменные и функции до их фактического объявления в коде.  
> ###### Hoisting переменных
>> 1. **Переменные, объявленные с помощью `var`**:  
>>    - Объявление переменной поднимается, но инициализация остаётся на месте.         
>>        ```javascript
>>        console.log(x); // undefined
>>        var x = 5;
>>        console.log(x); // 5
>>        ```     
>2. **Переменные, объявленные с помощью `let` и `const`**:
>>   
>>    - Объявление переменной поднимается, но она не инициализируется. Доступ к переменной до её объявления вызывает ошибку.
>>    - Пример:      
>>        ```javascript
>>        console.log(y); // ReferenceError: Cannot access 'y' before initialization
>>        let y = 10;
>>        ```
>> ###### Пример с глобальной и локальной переменными
>>>```js 
>>>function scope() {
>>>  a = 42;
>>>  var b = 43;
>>>}
>>>scope();
>>>console.log(a); // 42
>>>console.log(b); // ReferenceError: b is not defined
>>>```
>> Так как переменная `a` не была объявлена, то JavaScript сам решил, где объявлять переменную, и «поднял» объявление наверх. Получился вот такой код:
>>>```js 
>>>var a
>>>function scope() {
>>>  a = 42
>>>  var b = 43
>>>}
>>>scope()
>>>console.log(a)
>>>// 42
> >
> ###### Hoisting функций
> > 1. **Функции, объявленные с помощью `function`**:
> >    - Объявление и определение функции поднимаются, что позволяет вызывать функцию до её объявления.
> >        ```javascript
> >        catName("Тигр"); // "Мою кошку зовут Тигр"        
> >        function catName(name) {
> >          console.log("Мою кошку зовут " + name);
> >        }
> >        ```       
> >2. **Функции, присвоенные переменной**:    
> >    - Объявление переменной поднимается, но инициализация функцией не поднимается. Попытка вызвать функцию до её инициализации вызывает ошибку.
> >        ```javascript
> >        console.log(catName); // undefined
> >        catName("Тигр"); // TypeError: catName is not a function        
> >        var catName = function(name) {
> >          console.log("Мою кошку зовут " + name);
> >        };
>> 
>
> > [!summary]
>***Hoisting*** в JavaScript поднимает объявления переменных и функций в начало их области видимости. Это позволяет использовать их до фактического объявления в коде, но важно помнить, что инициализация переменных не поднимается. Переменные, объявленные с помощью `let` и `const`, ведут себя иначе и не доступны до их инициализации.      
# объявления-функций
> [!help] 
>###### Function Declaration (Объявление функции)
>>```js
>>function greet(name) {
>>    console.log(`Hello, ${name}!`);
>>}
>>greet("Alice"); // Выведет: Hello, Alice! 
>>```
>>**Особенности**:
>>- Поднимается [(hoisting)](#поднятие(hosting)) в начало своей области видимости.
>>- Можно вызвать до объявления в коде.
>>- Имеет свой собственный `this`.
>>
>>**Контекст**(`this`):
>>***Function Declaration*** создает свой собственный контекст выполнения. Значение `this` внутри такой функции зависит от того, как она вызывается.
>>```js
>>const obj = {
>>    name: "John",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm John
>>const hi = obj.sayHi;
>>hi(); // Выведет: Hi, I'm undefined (в нестрогом режиме) или выбросит ошибку (в строгом режиме)
>>```
> ###### Function Expression (Функциональное выражение)
>>```js
>>const greet = function(name) {
>>    console.log(`Hello, ${name}!`);
>>};
>>greet("Bob"); // Выведет: Hello, Bob!
>>```
>>**Особенности**:
>> - Не поднимается (no hoisting).
>> - Нельзя вызвать до объявления в коде.
>> - Может быть анонимной или именованной.
>> - Имеет свой собственный `this`.
>>
>>**Контекст**:
>>***Function Expression***, как и ***Function Declaration***, создает свой собственный контекст выполнения.
>>```js
>>const obj = {
>>    name: "Sarah",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm Sarah
> ###### Arrow Function (Стрелочная функция)
>>```js
>>const greet = (name) => {
>>    console.log(`Hello, ${name}!`);
>>};
>>
>>greet("Charlie"); // Выведет: Hello, Charlie!
>>```
>>**Особенности**:
>> - Более краткий синтаксис.
>> - Не имеет собственного `this`.
>> - Не может быть использована как конструктор.
>> - Не имеет собственного `arguments`.
>>> [!customname]- Что еще за `arguments`
>>> В JS, традиционные функции (***Function Declaration*** и ***Function Expression***) имеют доступ к специальному объекту `arguments`. Этот объект содержит все аргументы, переданные функции, даже если они не были объявлены в списке параметров.
>>>```js
>>>function regularFunction() {
>>>   console.log(arguments);
>>>   console.log(arguments.length);
>>>   console.log(arguments[0]);
>>>}
>>>regularFunction(1, 'a', true);
>>>// Выведет:
>>>// [1, 'a', true]
>>>// 3
>>>// 1
>>>```
>>> Однако стрелочные функции не имеют собственного `arguments`. Если вы попытаетесь получить доступ к arguments внутри стрелочной функции, вы получите `arguments` из внешней (не стрелочной) функции, если такая есть, или ошибку, если внешней функции нет.
>>>
>>>---
>>>
>>>**Пример со стрелочной функцией:**
>>>```js
>>>const arrowFunction = () => {
>>>    console.log(arguments);
>>>};
>>>arrowFunction(1, 'a', true);
>>>// Выбросит ошибку: ReferenceError: arguments is not defined
>>>```
>>>**Пример вложенной стрелочной функции:**
>>>```js
>>>function outerFunction() {
>>>    const arrowFunction = () => {
>>>        console.log(arguments);
>>>    };
>>>    arrowFunction(1, 'a', true);
>>>}
>>>outerFunction(4, 5, 6);
>>>// Выведет: [4, 5, 6]
>>>// Заметьте, что это аргументы внешней функции, а не стрелочной
>>
>> **Контекст**:
>>Arrow Function не создает свой собственный контекст выполнения. Вместо этого она захватывает this из окружающего лексического контекста.
>>```js
>>const obj = {
>>    name: "Mike",
>>    sayHi: () => {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm undefined
>>```
>
>**Пример, демонстрирующий разницу в контексте**:
>>> [!example] 
>>>```js
>>>  const obj = {
>>>    name: "Alice",
>>>    sayHiRegular: function() {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    },
>>>    sayHiArrow: () => {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    }
>>>};
>>>obj.sayHiRegular(); // Выведет: Hi, I'm Alice
>>>obj.sayHiArrow();   // Выведет: Hi, I'm undefined
>>>```
>>> **Использование в callback'ах**
>>>```js
>>>const objWithCallback = {
>>>    name: "Bob",
>>>    friends: ["Alice", "Charlie"],
>>>    greetFriendsRegular: function() {
>>>        this.friends.forEach(function(friend) {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь не ссылается на objWithCallback
>>>        });
>>>    },
>>>    greetFriendsArrow: function() {
>>>        this.friends.forEach((friend) => {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь ссылается на objWithCallback
>>>       });
>>>    }
>>>};
>>>objWithCallback.greetFriendsRegular(); // Выведет: undefined greets Alice, undefined greets Charlie
>>>objWithCallback.greetFriendsArrow();   // Выведет: Bob greets Alice, Bob greets Charlie
>>>```
>>>
>>>**Основные различия**:
>>> - ***Function Declaration*** поднимается, ***Function Expression*** и ***Arrow Function*** - нет.
>>> - ***Arrow Function*** не имеет собственного `this`, в отличие от других типов функций.
>>> - ***Arrow Functio***n имеет более краткий синтаксис.
>>> - ***Function Declaration*** и ***Function Expression*** могут быть использованы как конструкторы, ***Arrow Function*** - нет.
>
# event-loop
