# JS
> [!help] 
> 
>JavaScript - это:
>1. **Высокоуровневый язык программирования  **  
>    - Абстрагирован от машинного кода, более близок к человеческому языку.
>    - Обеспечивает автоматическое управление памятью (сборка мусора).
>2. **Динамически типизируемый **   
>    - Типы переменных определяются во время выполнения.
>    - Переменная может хранить значения разных типов в разное время.
>3. **Слабо типизированный**    
>    - Допускает неявное приведение типов.
>4. **Интерпретируемый**    
>    - Код выполняется построчно без предварительной компиляции.
>   > [!info]- 
>   >###### Построчное выполнение:
>   >   - Интерпретатор проходит по коду один раз, выполняя каждую инструкцию по порядку.
>   >###### Процесс выполнения:
>   >   - Код загружается и анализируется (парсится).
>   >   - Затем он выполняется сверху вниз, инструкция за инструкцией.
>   >   - После выполнения всех инструкций программа завершается, если нет бесконечных циклов или событийных слушателей.
>   >###### Контекст веб-страницы:
>   >   - В браузере JavaScript не "крутится" постоянно после загрузки страницы.
>   >   - Вместо этого, после выполнения начального кода, движок JavaScript ожидает событий (клики, таймеры и т.д.).
>   >###### Событийный цикл ([Event Loop](#event-loop)):
>   >   - JavaScript использует событийную модель.
>   >   - После выполнения начального кода, движок входит в состояние ожидания событий.
>   >   - Когда происходит событие, соответствующий обработчик выполняется.
>   >###### Память и выполнение:
>   >   - Интерпретатор не "запоминает" код в том смысле, в котором это делает компилятор.
>   >   - Однако, современные движки JavaScript (как V8) могут кэшировать результаты парсинга и даже компилировать часто используемый код (JIT-компиляция).
>   >###### Глобальный контекст:
>   >   - Глобальные переменные и функции остаются в памяти, пока страница открыта.
>   >   - Это позволяет обращаться к ним из обработчиков событий в любое время.
>    - Современные движки JS используют JIT-компиляцию для оптимизации производительности.
>   > [!info]- 
>   >JIT (Just-In-Time) подход позволяет JavaScript в Chrome быстро начинать выполнение (благодаря интерпретации) и достигать высокой производительности для критических участков кода (благодаря оптимизирующей компиляции).
>   > **JIT (Just-In-Time)** компиляция в V8 -  включает несколько уровней оптимизации. Вот как это работает в общих чертах:
>   >1. ***Интерпретация***:   
>   >    - Сначала весь код интерпретируется построчно интерпретатором Ignition.
>   >2. ***Профилирование***:    
>   >    - Во время выполнения V8 собирает информацию о том, как часто выполняются различные части кода и какие типы данных используются.
>   >3. ***Базовая JIT-компиляция***:    
>   >    - Часто выполняемые функции компилируются в машинный код компилятором TurboFan.
>   >    - Этот код быстрее интерпретируемого, но еще не полностью оптимизирован.
>   >4. ***Оптимизирующая компиляция***:    
>   >    - Для "горячего" кода (очень часто выполняемого) применяется агрессивная оптимизация.
>   >   - Здесь используется собранная информация о типах и поведении кода для создания высокооптимизированного машинного кода.
>   >5. ***Деоптимизация***:   
>   >    - Если предположения, сделанные при оптимизации, оказываются неверными (например, тип переменной изменился), код "деоптимизируется" и возвращается к менее оптимизированной версии или к интерпретации.
>   >6. ***Адаптивная оптимизация***:    
>   >    - V8 продолжает мониторить выполнение и может повторно оптимизировать код, если паттерны использования изменяются.
>   > ###### Ключевые моменты:
>   >>- Не весь код компилируется. Редко используемый код может остаться интерпретируемым.
>   >>- Компиляция происходит параллельно с выполнением программы.
>   >>- Уровень оптимизации зависит от частоты использования кода и стабильности типов.
>   >>- V8 балансирует между скоростью запуска (интерпретация) и скоростью выполнения (компиляция).
>  
>5. **Встраиваемый**    
>    - Может быть встроен в веб-браузеры и другие хост-среды (например, Node.js).
>    - Не имеет собственного ввода/вывода, полагается на хост-среду для этих функций.
>6. **Мультипарадигменный**   
>    - Поддерживает процедурное, объектно-ориентированное и функциональное программирование.
>7. **Прототипно-ориентированный**    
>    - Использует прототипы для наследования, в отличие от классического ООП.
>8. **Однопоточный с асинхронностью**    
>    - Имеет однопоточную модель выполнения.
>    - Поддерживает асинхронное программирование через callbacks, Promises и async/await.
>9. **Кроссплатформенный**   
>    - Работает на различных платформах и устройствах.
>10. **С поддержкой функций первого класса**    
>       - Функции могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
>       - 

# типы-данных
> [!help] 
> В JavaScript есть **8** основных типов данных:
>1. **Number** (число)
>    - Включает целые числа и числа с плавающей точкой.
>    - Пример: 42, 3.14
>2. **String** (строка)    
>    - Текстовые данные.
>    - Пример: "Hello", 'World'
>3. **Boolean** (логический тип)    
>    - true или false
>4. **Undefined**    
>    - Представляет переменную, которой не присвоено значение.
>    - ***typeof undefined*** возвращает ***"undefined"***
>5. **Null**   
>    - Представляет намеренное отсутствие какого-либо объектного значения.
>    - В отличие от undefined, null всегда присваивается намеренно.
>    - null используется для явного указания на отсутствие значения или "пустоту".
>    - ***typeof null*** возвращает ***"object"***
>6. **Object** (объект)    
>    - Коллекция свойств.
>    - Пример: {name: "John", age: 30}
>7. **Symbol** (символ)    
>    - Уникальный идентификатор.
>    - Введен в ECMAScript 6.
>8. **BigInt**    
>    - Для работы с целыми числами произвольной длины.
>    - Введен в ECMAScript 2020.
>    - Пример: 1234567890123456789012345678901234567890n
>> ###### Важные замечания:
>>1. **Массивы и функции**:    
>>    - Технически, массивы (Array) и функции (Function) являются подтипами Object. Но их часто рассматривают как отдельные типы из-за их особого поведения.
>>2. **Примитивные типы**:    
>>    - Number, String, Boolean, Undefined, Null, Symbol и BigInt считаются примитивными типами.
>>    - Object - это непримитивный тип.
>>3. **Специальные объекты**:    
>>    - Date, RegExp, Error и другие встроенные объекты часто упоминаются при обсуждении типов данных, но они являются подтипами Object.
>>4. **typeof оператор**:    
>>    - Оператор typeof может возвращать следующие строки: "number", "string", "boolean", "undefined", "object", "function", "symbol", "bigint".
>>    - Обратите внимание, что typeof null возвращает "object", что считается исторической ошибкой в языке.
>  

# var-let-const
> [!help] 
> 1. **var**:   
>    - [Функциональная область видимости](#области-видимости(блочная-функциональная))
>    - [Поднятие (hoisting)](#поднятие(hosting)) var поднимается и инициализируется значением undefined
>    - Можно переопределять
>    - Существует с начала JavaScript
>2. **let**:   
>    - [Блочная область видимости](#области-видимости(блочная-функциональная))
>    - [Нет поднятия](#поднятие(hosting)) (точнее, есть "временная мертвая зона"), поднимаются, но не инициализируются
>    - Можно переопределять
>    - Введено в ES6 (2015)
>3. **const**:   
>    - [Блочная область видимости](#области-видимости(блочная-функциональная))
>    - [Нет поднятия](#поднятие(hosting)) (как и let), поднимаются, но не инициализируются
>    - Нельзя переопределять (но можно изменять содержимое объектов)
>    - Введено в ES6 (2015)
>  
>  > [!info] 
>> Теоретические причины, по которым var может быть быстрее:
>>1. Отсутствие проверки временной мертвой зоны (TDZ):    
>>    - let и const имеют временную мертвую зону, var - нет.
>>    - Движок JS должен проверять, не находится ли переменная в TDZ при каждом обращении к ней.
>>2. Более простая область видимости:    
>>    - var имеет функциональную область видимости.
>>    - let и const имеют блочную область видимости, что может требовать более сложной логики для отслеживания.
>>3. Поднятие (hoisting):   
>>    - var поднимается и инициализируется значением undefined.
>>    - let и const поднимаются, но не инициализируются, что требует дополнительных проверок. 
# области-видимости(блочная-функциональная)
# поднятие(hosting)
# event-loop
