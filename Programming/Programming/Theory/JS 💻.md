# JS
> [!help] 
> 
>JavaScript - это:
>1. **Высокоуровневый язык программирования  **  
>    - Абстрагирован от машинного кода, более близок к человеческому языку.
>      > [!info]-
>      > JavaScript можно использовать для иллюстрации принципа ***абстракции*** в  ([[ООП]]). Абстракция позволяет нам работать с объектами через их интерфейсы, скрывая внутреннюю реализацию и сложность.
>    - Обеспечивает автоматическое управление памятью (сборка мусора).
>2. **Динамически типизируемый **   
>    - Типы переменных определяются во время выполнения.
>    - Переменная может хранить значения разных типов в разное время.
>3. **Слабо типизированный**    
>    - Допускает неявное приведение типов.
>4. **Интерпретируемый**    
>    - Код выполняется построчно без предварительной компиляции.
>   > [!info]- 
>   >###### Построчное выполнение:
>   >   - Интерпретатор проходит по коду один раз, выполняя каждую инструкцию по порядку.
>   >###### Процесс выполнения:
>   >   - Код загружается и анализируется (парсится).
>   >   - Затем он выполняется сверху вниз, инструкция за инструкцией.
>   >   - После выполнения всех инструкций программа завершается, если нет бесконечных циклов или событийных слушателей.
>   >###### Контекст веб-страницы:
>   >   - В браузере JavaScript не "крутится" постоянно после загрузки страницы.
>   >   - Вместо этого, после выполнения начального кода, движок JavaScript ожидает событий (клики, таймеры и т.д.).
>   >###### Событийный цикл ([Event Loop](#event-loop)):
>   >   - JavaScript использует событийную модель.
>   >   - После выполнения начального кода, движок входит в состояние ожидания событий.
>   >   - Когда происходит событие, соответствующий обработчик выполняется.
>   >###### Память и выполнение:
>   >   - Интерпретатор не "запоминает" код в том смысле, в котором это делает компилятор.
>   >   - Однако, современные движки JavaScript (как V8) могут кэшировать результаты парсинга и даже компилировать часто используемый код (JIT-компиляция).
>   >###### Глобальный контекст:
>   >   - Глобальные переменные и функции остаются в памяти, пока страница открыта.
>   >   - Это позволяет обращаться к ним из обработчиков событий в любое время.
>    - Современные движки JS используют JIT-компиляцию для оптимизации производительности.
>   > [!info]- 
>   >JIT (Just-In-Time) подход позволяет JavaScript в Chrome быстро начинать выполнение (благодаря интерпретации) и достигать высокой производительности для критических участков кода (благодаря оптимизирующей компиляции).
>   > **JIT (Just-In-Time)** компиляция в V8 -  включает несколько уровней оптимизации. Вот как это работает в общих чертах:
>   >1. ***Интерпретация***:   
>   >    - Сначала весь код интерпретируется построчно интерпретатором Ignition.
>   >2. ***Профилирование***:    
>   >    - Во время выполнения V8 собирает информацию о том, как часто выполняются различные части кода и какие типы данных используются.
>   >3. ***Базовая JIT-компиляция***:    
>   >    - Часто выполняемые функции компилируются в машинный код компилятором TurboFan.
>   >    - Этот код быстрее интерпретируемого, но еще не полностью оптимизирован.
>   >4. ***Оптимизирующая компиляция***:    
>   >    - Для "горячего" кода (очень часто выполняемого) применяется агрессивная оптимизация.
>   >   - Здесь используется собранная информация о типах и поведении кода для создания высокооптимизированного машинного кода.
>   >5. ***Деоптимизация***:   
>   >    - Если предположения, сделанные при оптимизации, оказываются неверными (например, тип переменной изменился), код "деоптимизируется" и возвращается к менее оптимизированной версии или к интерпретации.
>   >6. ***Адаптивная оптимизация***:    
>   >    - V8 продолжает мониторить выполнение и может повторно оптимизировать код, если паттерны использования изменяются.
>   > ###### Ключевые моменты:
>   >>- Не весь код компилируется. Редко используемый код может остаться интерпретируемым.
>   >>- Компиляция происходит параллельно с выполнением программы.
>   >>- Уровень оптимизации зависит от частоты использования кода и стабильности типов.
>   >>- V8 балансирует между скоростью запуска (интерпретация) и скоростью выполнения (компиляция).
>  
>5. **Встраиваемый**    
>    - Может быть встроен в веб-браузеры и другие хост-среды (например, Node.js).
>    - Не имеет собственного ввода/вывода, полагается на хост-среду для этих функций.
>6. **Мультипарадигменный**   
>    - Поддерживает процедурное, объектно-ориентированное и функциональное программирование.
>      > [!info]- 
>      > ###### Основные парадигмы программирования:
>      >>1. ***Императивное программирование***
>      >>    - Процедурное программирование
>      >>    - Объектно-ориентированное программирование ([[ООП]])
>      >>2. ***Декларативное программирование ***   
>      >>    - Функциональное программирование
>      >>    - Логическое программирование
>      >>3. ***Структурное программирование***    
>      >>4. ***Событийно-ориентированное программирование***  
>      >>5. ***Аспектно-ориентированное программирование***    
>      >>6. ***Прототипно-ориентированное программирование***    
>      >>7. ***Компонентно-ориентированное программирование***    
>      >>8. ***Параллельное программирование***
>      >>9. ***Реактивное программирование***   
>      > ###### Парадигмы, которые хорошо подходят для JavaScript и широко в нем используются:
>      >>1. ***Процедурное программирование***:  
>      >>    JavaScript позволяет писать последовательные инструкции и организовывать код в функции.   
>      >>    ```js
>      >>    function calculateArea(width, height) {
>      >>        return width * height;
>      >>    }
>      >>      
>      >> 2. ***Объектно-ориентированное программирование***:  
>      >>    JavaScript поддерживает ООП как через прототипы, так и через классы (с ES6).  
>      >>    ```js
>      >>    class Rectangle {
>      >>        constructor(width, height) {
>      >>           this.width = width;
>      >>            this.height = height;
>      >>        }
>      >>        
>      >>        getArea() {
>      >>            return this.width * this.height;
>      >>        }
>      >>    }
>      >>    ```   
>      >>3. ***Функциональное программирование***:  
>      >>    JavaScript поддерживает функции первого класса, замыкания и другие функциональные концепции.    
>      >>    ```js
>      >>   const multiply = (a, b) => a * b;
>      >>    const numbers = [1, 2, 3, 4, 5];
>      >>    const doubled = numbers.map(n => n * 2);
>      >>    ```    
>      >>4. ***Прототипно-ориентированное программирование***:  
>      >>    Это основной механизм наследования в JavaScript.   
>      >>    ```js
>      >>    function Animal(name) {
>      >>        this.name = name;
>      >>    }
>      >>    Animal.prototype.speak = function() {
>      >>        console.log(this.name + ' makes a noise.');
>      >>    };
>      >>    ```
>      >>   
>      >>5. ***Событийно-ориентированное программирование***:  
>      >>    Широко используется в JavaScript, особенно в веб-разработке.
>      >>    ```
>      >>    document.getElementById('myButton').addEventListener('click', function() {
>      >>        console.log('Button clicked!');
>      >>    });
>      >>    ```  
>      >>6. ***Компонентно-ориентированное программирование***:  
>      >>    Популярно в современных фреймворках, таких как React, Vue, Angular.
>      >>    ```ts
>      >>   // Пример React-компонента
>      >>    function Welcome(props) {
>      >>        return <h1>Hello, {props.name}</h1>;
>      >>    }
>      >>    ```   
>      >>7. ***Реактивное программирование***:  
>      >>    Поддерживается через библиотеки, такие как RxJS.
>      >>    ```js
>      >>    // Пример с использованием RxJS
>      >>    import { fromEvent } from 'rxjs';
>      >>    import { map } from 'rxjs/operators';
>      >>    
>      >>    const clicks = fromEvent(document, 'click');
>      >>    const positions = clicks.pipe(map(ev => ev.clientX));
>      >>    positions.subscribe(x => console.log(x));
>      >>    ```   
>      >>8. ***Асинхронное программирование***:  
>      >>    JavaScript отлично поддерживает асинхронное программирование через callbacks, promises и async/await.
>      >>    ```js
>      >>    async function fetchData() {
>      >>       try {
>      >>            const response = await fetch('https://api.example.com/data');
>      >>            const data = await response.json();
>      >>            console.log(data);
>      >>        } catch (error) {
>      >>            console.error('Fetching error:', error);
>      >>        }
>      >>    }
>      >>    ```
>      >> ###### Заключение:  
>      >>>JavaScript действительно является мультипарадигменным языком, поддерживающим множество различных подходов к программированию. Это дает разработчикам большую гибкость в выборе наиболее подходящего стиля для конкретной задачи или проекта. Наиболее часто в JavaScript используются процедурное, объектно-ориентированное и функциональное программирование, но язык также хорошо поддерживает событийно-ориентированное, компонентно-ориентированное и реактивное программирование. Выбор парадигмы часто зависит от конкретных требований проекта, личных предпочтений разработчика и используемых фреймворков или библиотек.
>      > 
>      > 
>  
>7. **Прототипно-ориентированный**    
>    - Использует прототипы для наследования, в отличие от классического [[ООП]].
>8. **Однопоточный с асинхронностью**    
>    - Имеет однопоточную модель выполнения.
>    - Поддерживает асинхронное программирование через callbacks, Promises и async/await.
>9. **Кроссплатформенный**   
>    - Работает на различных платформах и устройствах.
>10. **С поддержкой функций первого класса**    
>       - Функции могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
>       - 

# типы-данных
> [!help] 
> В JavaScript есть **8** основных типов данных:
>1. **Number** (число)
>    - Включает целые числа и числа с плавающей точкой.
>    - Пример: 42, 3.14
>2. **String** (строка)    
>    - Текстовые данные.
>    - Пример: "Hello", 'World'
>3. **Boolean** (логический тип)    
>    - true или false
>4. **Undefined**    
>    - Представляет переменную, которой не присвоено значение.
>    - ***typeof undefined*** возвращает ***"undefined"***
>5. **Null**   
>    - Представляет намеренное отсутствие какого-либо объектного значения.
>    - В отличие от undefined, null всегда присваивается намеренно.
>    - null используется для явного указания на отсутствие значения или "пустоту".
>    - ***typeof null*** возвращает ***"object"***
>6. **Object** (объект)    
>    - Коллекция свойств.
>    - Пример: {name: "John", age: 30}
>7. **Symbol** (символ)    
>    - Уникальный идентификатор.
>    - Введен в ECMAScript 6.
>8. **BigInt**    
>    - Для работы с целыми числами произвольной длины.
>    - Введен в ECMAScript 2020.
>    - Пример: 1234567890123456789012345678901234567890n
> ###### Важные замечания:
>>1. **Массивы и функции**:    
>>    - Технически, массивы (Array) и функции (Function) являются подтипами Object. Но их часто рассматривают как отдельные типы из-за их особого поведения.
>>2. **Примитивные типы**:    
>>    - Number, String, Boolean, Undefined, Null, Symbol и BigInt считаются примитивными типами.
>>    - Object - это непримитивный тип.
>>3. **Специальные объекты**:    
>>    - Date, RegExp, Error и другие встроенные объекты часто упоминаются при обсуждении типов данных, но они являются подтипами Object.
>>4. **typeof оператор**:    
>>    - Оператор typeof может возвращать следующие строки: "number", "string", "boolean", "undefined", "object", "function", "symbol", "bigint".
>>    - Обратите внимание, что typeof null возвращает "object", что считается исторической ошибкой в языке.
>  

# var-let-const
> [!help] 
> 1. **var**:   
>    - [Функциональная область видимости](#области-видимости) 
>         - если объявлена вне функции, то имеет [глобальную область видимости](#области-видимости).
>    - [Поднятие (hoisting)](#поднятие(hosting)) `var` поднимается и инициализируется значением undefined
>    - Можно переопределять
>    - Существует с начала JavaScript
>2. **let**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (точнее, есть "временная мертвая зона"), поднимаются, но не инициализируются
>    - Можно переопределять
>    - Введено в ES6 (2015)
>3. **const**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (как и `let`), поднимаются, но не инициализируются
>    - Нельзя переопределять (но можно изменять содержимое объектов)
>    - Введено в ES6 (2015)
>  
>  > [!example] 
>   >> Если `var` объявлена вне функции, она становится глобальной переменной и свойством глобального объекта (`window` в браузере).
>   >> ```js
>   >>var globalVar = "I'm global";
>   >>console.log(window.globalVar); // "I'm global" (в браузере)
>   >>console.log(globalVar);        // "I'm global" (в браузере)
>   >>```
>   >>Переменная `globalVar`, объявленная с помощью `var`, становится как глобальной переменной, так и свойством объекта `window`. Поэтому мы можем обращаться к ней обоими способами.
>   > ---
>   >>Если `let` или `const` объявлены вне любого блока (в глобальной области), они становятся глобальными переменными, но не становятся свойствами глобального объекта.
>   >> ```js
>   >>let globalLet = "I'm global";
>   >>const globalConst = "I'm also global";
>   >>console.log(window.globalLet);    // undefined (в браузере)
>   >>console.log(window.globalConst);  // undefined (в браузере)
>   >>console.log(globalLet);    // "I'm global" (в браузере)
>   >>console.log(globalConst);  // "I'm also global" (в браузере)
>   >>```
>   >> Переменные `globalLet` и `globalConst`, хотя и являются глобальными (доступны во всем скрипте), не становятся свойствами объекта `window`. Поэтому мы можем обращаться к ним напрямую, но не через window.
>
>  > [!info] 
>> Теоретические причины, по которым var может быть быстрее:
>>1. Отсутствие проверки временной мертвой зоны (TDZ):    
>>    - let и const имеют временную мертвую зону, var - нет.
>>    - Движок JS должен проверять, не находится ли переменная в TDZ при каждом обращении к ней.
>>2. Более простая область видимости:    
>>    - var имеет функциональную область видимости.
>>    - let и const имеют блочную область видимости, что может требовать более сложной логики для отслеживания.
>>3. Поднятие (hoisting):   
>>    - var поднимается и инициализируется значением undefined.
>>    - let и const поднимаются, но не инициализируются, что требует дополнительных проверок. 
>>      
# области-видимости

> [!help] 
>> [!quote] 
>>  - **Глобальная область видимости** - Это самый внешний уровень области видимости. Переменные, объявленные здесь, доступны во всем скрипте.
>
>> [!quote] 
>>  - **Функциональная область видимости** -  Переменные, объявленные внутри функции, доступны только внутри этой функции.
>
>> [!quote] 
>>  - **Блочная область видимости** - Переменные доступны только внутри блока, где они объявлены.
>  
# поднятие(hosting)
> [!help] 
> > [!quote] 
> **Hoisting** (поднятие) — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их [области видимости](#области-видимости) во время выполнения кода. Это позволяет использовать переменные и функции до их фактического объявления в коде.  
> ###### Hoisting переменных
>> 1. **Переменные, объявленные с помощью `var`**:  
>>    - Объявление переменной поднимается, но инициализация остаётся на месте.         
>>        ```javascript
>>        console.log(x); // undefined
>>        var x = 5;
>>        console.log(x); // 5
>>        ```     
>2. **Переменные, объявленные с помощью `let` и `const`**:
>>   
>>    - Объявление переменной поднимается, но она не инициализируется. Доступ к переменной до её объявления вызывает ошибку.
>>    - Пример:      
>>        ```javascript
>>        console.log(y); // ReferenceError: Cannot access 'y' before initialization
>>        let y = 10;
>>        ```
>> ###### Пример с глобальной и локальной переменными
>>>```js 
>>>function scope() {
>>>  a = 42;
>>>  var b = 43;
>>>}
>>>scope();
>>>console.log(a); // 42
>>>console.log(b); // ReferenceError: b is not defined
>>>```
>> Так как переменная `a` не была объявлена, то JavaScript сам решил, где объявлять переменную, и «поднял» объявление наверх. Получился вот такой код:
>>>```js 
>>>var a
>>>function scope() {
>>>  a = 42
>>>  var b = 43
>>>}
>>>scope()
>>>console.log(a)
>>>// 42
> >
> ###### Hoisting функций
> > 1. **Функции, объявленные с помощью `function`**:
> >    - Объявление и определение функции поднимаются, что позволяет вызывать функцию до её объявления.
> >        ```javascript
> >        catName("Тигр"); // "Мою кошку зовут Тигр"        
> >        function catName(name) {
> >          console.log("Мою кошку зовут " + name);
> >        }
> >        ```       
> >2. **Функции, присвоенные переменной**:    
> >    - Объявление переменной поднимается, но инициализация функцией не поднимается. Попытка вызвать функцию до её инициализации вызывает ошибку.
> >        ```javascript
> >        console.log(catName); // undefined
> >        catName("Тигр"); // TypeError: catName is not a function        
> >        var catName = function(name) {
> >          console.log("Мою кошку зовут " + name);
> >        };
>> 
>
> > [!summary]
>***Hoisting*** в JavaScript поднимает объявления переменных и функций в начало их области видимости. Это позволяет использовать их до фактического объявления в коде, но важно помнить, что инициализация переменных не поднимается. Переменные, объявленные с помощью `let` и `const`, ведут себя иначе и не доступны до их инициализации.      
# объявления-функций
> [!help] 
>###### Function Declaration (Объявление функции)
>>```js
>>function greet(name) {
>>    console.log(`Hello, ${name}!`);
>>}
>>greet("Alice"); // Выведет: Hello, Alice! 
>>```
>>**Особенности**:
>>- Поднимается [(hoisting)](#поднятие(hosting)) в начало своей области видимости.
>>- Можно вызвать до объявления в коде.
>>- Имеет свой собственный `this`.
>>
>>**Контекст**(`this`):
>>***Function Declaration*** создает свой собственный контекст выполнения. Значение `this` внутри такой функции зависит от того, как она вызывается.
>>```js
>>const obj = {
>>    name: "John",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm John
>>const hi = obj.sayHi;
>>hi(); // Выведет: Hi, I'm undefined (в нестрогом режиме) или выбросит ошибку (в строгом режиме)
>>```
> ###### Function Expression (Функциональное выражение)
>>```js
>>const greet = function(name) {
>>    console.log(`Hello, ${name}!`);
>>};
>>greet("Bob"); // Выведет: Hello, Bob!
>>```
>>**Особенности**:
>> - Не поднимается (no hoisting).
>> - Нельзя вызвать до объявления в коде.
>> - Может быть анонимной или именованной.
>> - Имеет свой собственный `this`.
>>
>>**Контекст**:
>>***Function Expression***, как и ***Function Declaration***, создает свой собственный контекст выполнения.
>>```js
>>const obj = {
>>    name: "Sarah",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm Sarah
> ###### Arrow Function (Стрелочная функция)
>>```js
>>const greet = (name) => {
>>    console.log(`Hello, ${name}!`);
>>};
>>
>>greet("Charlie"); // Выведет: Hello, Charlie!
>>```
>>**Особенности**:
>> - Более краткий синтаксис.
>> - Не имеет собственного `this`.
>> - Не может быть использована как конструктор.
>> - Не имеет собственного `arguments`.
>>> [!customname]- Что еще за `arguments`
>>> В JS, традиционные функции (***Function Declaration*** и ***Function Expression***) имеют доступ к специальному объекту `arguments`. Этот объект содержит все аргументы, переданные функции, даже если они не были объявлены в списке параметров.
>>>```js
>>>function regularFunction() {
>>>   console.log(arguments);
>>>   console.log(arguments.length);
>>>   console.log(arguments[0]);
>>>}
>>>regularFunction(1, 'a', true);
>>>// Выведет:
>>>// [1, 'a', true]
>>>// 3
>>>// 1
>>>```
>>> Однако стрелочные функции не имеют собственного `arguments`. Если вы попытаетесь получить доступ к arguments внутри стрелочной функции, вы получите `arguments` из внешней (не стрелочной) функции, если такая есть, или ошибку, если внешней функции нет.
>>>
>>>---
>>>
>>>**Пример со стрелочной функцией:**
>>>```js
>>>const arrowFunction = () => {
>>>    console.log(arguments);
>>>};
>>>arrowFunction(1, 'a', true);
>>>// Выбросит ошибку: ReferenceError: arguments is not defined
>>>```
>>>**Пример вложенной стрелочной функции:**
>>>```js
>>>function outerFunction() {
>>>    const arrowFunction = () => {
>>>        console.log(arguments);
>>>    };
>>>    arrowFunction(1, 'a', true);
>>>}
>>>outerFunction(4, 5, 6);
>>>// Выведет: [4, 5, 6]
>>>// Заметьте, что это аргументы внешней функции, а не стрелочной
>>
>> **Контекст**:
>>Arrow Function не создает свой собственный контекст выполнения. Вместо этого она захватывает `this` из окружающего лексического контекста.
>>```js
>>const obj = {
>>    name: "Mike",
>>    sayHi: () => {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm undefined
>>```
>
>**Пример, демонстрирующий разницу в контексте**:
>>> [!example] 
>>>```js
>>>  const obj = {
>>>    name: "Alice",
>>>    sayHiRegular: function() {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    },
>>>    sayHiArrow: () => {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    }
>>>};
>>>obj.sayHiRegular(); // Выведет: Hi, I'm Alice
>>>obj.sayHiArrow();   // Выведет: Hi, I'm undefined
>>>```
>>> **Использование в callback'ах**
>>>```js
>>>const objWithCallback = {
>>>    name: "Bob",
>>>    friends: ["Alice", "Charlie"],
>>>    greetFriendsRegular: function() {
>>>        this.friends.forEach(function(friend) {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь не ссылается на objWithCallback
>>>        });
>>>    },
>>>    greetFriendsArrow: function() {
>>>        this.friends.forEach((friend) => {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь ссылается на objWithCallback
>>>       });
>>>    }
>>>};
>>>objWithCallback.greetFriendsRegular(); // Выведет: undefined greets Alice, undefined greets Charlie
>>>objWithCallback.greetFriendsArrow();   // Выведет: Bob greets Alice, Bob greets Charlie
>>>```
>>>
>>>**Основные различия**:
>>> - ***Function Declaration*** поднимается, ***Function Expression*** и ***Arrow Function*** - нет.
>>> - ***Arrow Function*** не имеет собственного `this`, в отличие от других типов функций.
>>> - ***Arrow Functio***n имеет более краткий синтаксис.
>>> - ***Function Declaration*** и ***Function Expression*** могут быть использованы как конструкторы, ***Arrow Function*** - нет.
>
# замыкание
> [!help] 
>>[!quote]
>> **Замыкание**(Closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Другими словами, это способность функции запоминать и получать доступ к переменным из внешней по отношению к ней области видимости, даже когда функция выполняется вне этой области видимости.
>
> ###### Ключевые аспекты замыканий:
>> 1. **Функция внутри функции**:
>>      - Замыкание обычно создается, когда вы определяете функцию внутри другой функции.
>>2. **Доступ к переменным внешней функции**:
>>      - Внутренняя функция имеет доступ к переменным внешней функции.
>>3. **Сохранение состояния**:
>>     - Замыкания позволяют сохранять состояние между вызовами функций.
>>        Главное - ***сохранить ссылку на возвращаемый объект***, чтобы иметь доступ к методам и сохранить замыкание.
>>        У каждого присваивания будет свой скоуп.(см Пример Работы с разными вызовами)
>>> [!example]+ Примеры как сохраняется состояние и не сохраняется 
>>>```js
>>>function createCounter() {
>>>    let count = 0;    
>>>    return {
>>>        increment: function() {
>>>            count++;
>>>        },
>>>        getCount: function() {
>>>            return count;
>>>        }
>>>    };
>>>}
>>>```
>>> ###### Использование с присваиванием
>>>```js 
>>>const counter1 = createCounter();
>>>counter1.increment();
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 2
>>>```
>>>
>>> ***Использование как свойства объекта:***
>>>```js 
>>>const obj = {
>>>    counter: createCounter()
>>>};
>>>obj.counter.increment();
>>>console.log(obj.counter.getCount()); // Выведет: 1
>>>```
>>>
>>> ***Передача как аргумента функции:***
>>>```js 
>>>function useCounter(counter) {
>>>    counter.increment();
>>>    console.log(counter.getCount());
>>>}
>>>useCounter(createCounter()); // Выведет: 1
>>>```
>>> ###### Пример Работы с разными вызовами
>>>```js 
>>>const counter1 = createCounter();
>>>const counter2 = createCounter();
>>>
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 1
>>>console.log(counter2.getCount()); // Выведет: 0
>>>```
>>>###### Использование без присваивания
>>>```js 
>>>console.log(createCounter().getCount()); // Всегда выведет: 0
>>>createCounter().increment();
>>>console.log(createCounter().getCount()); // Все равно выведет: 0
>>>```
>
>>[!example]
>> ###### Пример простого замыкания:
>>```js
>>function outerFunction(x) {
>>    let y = 10;    
>>    function innerFunction() {
>>        console.log(x + y);
>>    }    
>>    return innerFunction;
>>}
>>const closure = outerFunction(5);
>>closure(); // Выведет: 15
>>```
>>
>>В этом примере `innerFunction` является замыканием. Она "запоминает" значения `x` и `y`, даже после того, как `outerFunction` завершила свое выполнение.
>> ###### Пример инкапсуляции и приватных переменных:
>>```js
>>function createCounter() {
>>    let count = 0;    
>>    return {
>>        increment: function() {
>>            count++;
>>        },
>>        getCount: function() {
>>            return count;
>>        }
>>    };
>>}
>>const counter = createCounter();
>>counter.increment();
>>counter.increment();
>>console.log(counter.getCount()); // Выведет: 2
>>console.log(counter.count); // Выведет: undefined
>>```
# каррирование
> [!help] 
>>[!quote]
>> **Каррирование (Currying)** - это техника в функциональном программировании, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает один аргумент. `funcName(1)(2)(3)`
>
> Основная идея каррирования заключается в том, чтобы сделать функции более гибкими и переиспользуемыми. Хотя каррирование не используется так часто, как некоторые другие паттерны, оно может быть очень полезным в определенных ситуациях.
>
>>[!example] Базовый пример каррирования:
>>```js 
>>// Обычная функция
>>function add(a, b, c) {
>>    return a + b + c;
>>}
>>
>>// Каррированная версия
>>function curriedAdd(a) {
>>    return function(b) {
>>        return function(c) {
>>            return a + b + c;
>>        }
>>    }
>>}
>>
>>console.log(add(1, 2, 3)); // 6
>>console.log(curriedAdd(1)(2)(3)); // 6
>>
>>// Частичное применение
>>const add1 = curriedAdd(1);
>>const add1And2 = add1(2);
>>
>>console.log(add1And2(3)); // 6
>>```

# прототипное наследование
> [!help] 
>>[!quote]
>**Прототипное наследование** в JS — это механизм, с помощью которого объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. Это позволяет избежать дублирования кода и позволяет объектам использовать свойства и методы своих "родителей".
> ###### Как работает прототипное наследование?
>>Когда ты пытаешься получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте.
>>Если свойство или метод не найдено, JavaScript продолжает поиск в прототипе объекта (то есть в объекте, от которого наследуется текущий объект).
>>Этот процесс продолжается до тех пор, пока не найдётся нужное свойство или не достигнут объект без прототипа (обычно это `null`).
>>>[!example] Пример базового прототипного наследования
>>>```javascript
>>> const animal = {
>>>  speak() {
>>>    return "Animal sound";
>>>  }
>>>};
>>>```
>>>```javascript
>>>const dog = {
>>>  bark() {
>>>    return "Woof!";
>>>  }
>>>};
>>>// Назначаем animal прототипом для dog
>>>Object.setPrototypeOf(dog, animal);
>>>
>>>console.log(dog.bark());   // "Woof!" - метод dog
>>>console.log(dog.speak());  // "Animal sound" - метод наследован от animal
>>
>>>[!example] Реализация кастомного метода `flat` с индексом
>>>```javascript
>>>const arr = [1,2,3,4,5]
>>>
>>>Array.prototype.myFlat = function(index){
>>>  const res = []
>>>  
>>>  const newFlat= this.flat(Infinity)
>>>  
>>>  newFlat.forEach((item,i)=>{
>>>    if(i===index) res.push([item])
>>>    else res.push(item)
>>>  })
>>>  
>>>  return res 
>>>}
>>>
>>>console.log(arr.myFlat(3)) //[ 1, 2, 3, [ 4 ], 5 ]
>>
>>>[!example] Реализация кастомного метода `filter`
>>>```javascript
>>>const arr = [1,2,3,4,5]
>>>
>>>Array.prototype.myFilter = function(func){ // func - это callback
>>>  const res = []
>>>  
>>>  this.forEach((item)=>{
>>>    if(func(item)) res.push(item)
>>>  })
>>>  return res
>>>}
>>>
>>>console.log(arr.myFilter(item=> item % 2)) //[ 1, 3, 5 ]
>>>console.log(arr.filter((item)=>item % 2)) //[ 1, 3, 5 ]
>>

> ###### Методы для работы с прототипами
>> 1. **Object.setPrototypeOf()** - используется для назначения прототипа для объекта. Это современный и предпочтительный метод по сравнению с устаревшим `__proto__`.
>>>```javascript
>>>const animal = { legs: 4 };
>>>const cat = {};
>>>// Назначаем animal как прототип для cat
>>>Object.setPrototypeOf(cat, animal);
>>>
>>>console.log(cat.legs); // 4
>> 2. **Object.getPrototypeOf()** - возвращает прототип объекта, то есть объект, от которого он наследует.
>>>```javascript
>>>const proto = Object.getPrototypeOf(cat);
>>>console.log(proto); // { legs: 4 }
>>>console.log(proto === animal); // true
>>
> ###### Почему не используют `__proto__`
>>**`__proto__`** — это старый способ манипулирования прототипами, который считается небезопасным и неэффективным. Использование `Object.setPrototypeOf` и `Object.getPrototypeOf` предпочтительнее из-за лучшей производительности и поддержки стандартов.
>>```javascript
>>// Устаревший способ
>>cat.__proto__ = animal;
> ###### Изменение прототипа и его влияние
>>Когда ты изменяешь свойства или методы объекта-прототипа, это изменение отразится на всех объектах, которые используют этот объект в качестве прототипа.
>>```javascript
>>const bird = {
>>  fly() {
>>    return "Flying";
>>  }
>>};
>>
>>const eagle = {};
>>Object.setPrototypeOf(eagle, bird);
>>
>>console.log(eagle.fly()); // "Flying"
>>// Изменяем метод в прототипе
>>bird.fly = function() {
>>  return "Soaring!";
>>};
>>
>>console.log(eagle.fly()); // "Soaring!" - наследует изменённый метод
> ###### Примитивы и временные объектные обёртки
>>Примитивы, такие как строки и числа, при вызове методов временно преобразуются в объектные обёртки (String, Number и т.д.), что позволяет работать с методами этих типов данных. Можно добавлять свои методы в их прототипы.
>>>[!example] Пример с добавлением метода в String.prototype
>>>```javascript
>>>String.prototype.reverse = function() {
>>>  return this.split('').reverse().join('');
>>>};
>>>
>>>console.log("hello".reverse()); // "olleh"
> ###### **.prototype** и функции-конструкторы
>>**.prototype** — это специальное свойство функций-конструкторов, которое позволяет задавать методы и свойства для всех объектов, созданных через этот конструктор. Это не используется для обычных объектов.
>>```javascript
>>function Person(name) {
>>  this.name = name;
>>}
>>
>>Person.prototype.greet = function() {
>>  return `Hello, my name is ${this.name}`;
>>};
>>
>>const alice = new Person("Alice");
>>console.log(alice.greet()); // "Hello, my name is Alice"
> ###### Итоговое резюме:
>> **Прототипное наследование** — это механизм, который позволяет объектам наследовать свойства и методы от других объектов через цепочку прототипов.
>> - Используй `Object.setPrototypeOf(obj, proto)` для назначения прототипа объекта.
>> - Используй `Object.getPrototypeOf(obj)` для получения прототипа объекта.
>> - Не используй `__proto__` из-за его устаревшего статуса и низкой производительности.
>> - Изменения в объекте-прототипе отражаются на всех объектах, которые его используют.
>>`.prototype` используется для функций-конструкторов и классов, чтобы создавать общие методы для всех объектов, созданных через них.
>> - Примитивные типы данных, такие как строки и числа, временно преобразуются в объектные обёртки, что позволяет расширять их прототипы методами (например, добавление метода в `String.prototype`).

# this
> [!help] 
>>[!quote]
>>`this` - это ключевое слово, которое ссылается на контекст выполнения функции. 
>
>Значение `this` может меняться в зависимости от того, как функция вызывается.
> ###### Основные правила определения `this`: 
>>1. **Глобальный контекст**:
>>      - В браузере: `this` указывает на объект `window`
>>      - В Node.js: `this` указывает на глобальный объект `global`
>>2. **Внутри функции (простой вызов)**:
>>      - В строгом режиме `('use strict')`: `this` будет `undefined`
>>      - В нестрогом режиме: `this` будет глобальным объектом
>>3. **Метод объекта**:
>>      - `this` указывает на объект, который вызывает метод 
>>4. **Конструктор**:
>>      - `this` указывает на новосозданный объект 
>>5. **Стрелочные функции**:
>>      - `this` берется из окружающего лексического контекста
>
>>[!example] Глобальный контекст
>>```javascript
>>console.log(this); // window в браузере, global в Node.js
>>```
>
>>[!example] Простой вызов функции
>>```javascript
>>function simpleFunc() {
>>    console.log(this);
>>}
>>simpleFunc(); // window в браузере (нестрогий режим), undefined в строгом режиме
>>```
>
>>[!example] Метод объекта
>>```javascript
>>let obj = {
>>    method: function() {
>>        console.log(this);
>>    }
>>};
>>obj.method(); // {method: ƒ} в браузере
>>```
>
>>[!example] Конструктор
>>```javascript
>>function Constructor() {
>>    console.log(this);
>>}
>>new Constructor(); // новый объект Constructor {}
>>```
>
>>[!example] Стрелочная функция
>>```javascript
>>let arrowFunc = () => {
>>    console.log(this);
>>};
>>arrowFunc(); // window в браузере, global в Node.js
>>```
>
> ###### Методы изменения контекста: 
>>
>>>[!example] Вызывает функцию с заданным `this` и аргументами, переданными отдельно.
>>>```javascript
>>>function greet(greeting) {
>>>    console.log(greeting + ', ' + this.name);
>>>}
>>
>>>[!example]  **call()**
>>>```javascript
>>>let person = { name: 'John' };
>>>greet.call(person, 'Hello'); // "Hello, John"
>>>```
>>
>>>[!example] **apply()** - gохож на **call()**, но аргументы передаются массивом
>>>```javascript
>>>greet.apply(person, ['Hi']); // "Hi, John"
>>>```
>>
>>>[!example] **bind()** - cоздает новую функцию с привязанным контекстом.
>>>```javascript
>>>let boundGreet = greet.bind(person);
>>>boundGreet('Hey'); // "Hey, John"
>>>```
>>
> ###### Особые случаи: 
>>1. **События DOM (в браузере)**:
>>>[!example] `this` указывает на элемент, который вызвал событие
>>>```javascript
>>>document.querySelector('button').addEventListener('click', function() {
>>>    console.log(this); // <button> элемент
>>>});
>>>```
>>
>>2. **Стрелочные функции как методы:**:
>>>[!example] `this` будет `undefined` в стрелочной фукнции
>>>```javascript
>>>let obj = {
>>>    name: 'Object',
>>>    arrowMethod: () => {
>>>        console.log(this.name);
>>>    },
>>>    regularMethod: function() {
>>>        console.log(this.name);
>>>    }
>>>};
>>>
>>>obj.arrowMethod();   // undefined (this указывает на глобальный объект)
>>>obj.regularMethod(); // "Object"
>>>```
>>
>>
>>3. **`this` в присвоеннх переменных**:
>>>>[!example] основной обьект
>>>>```javascript
>>>>let person = {
>>>>    name: "John",
>>>>   sayHello: function() {
>>>>        return "Hello, my name is " + this.name;
>>>>    }
>>>>};
>>>
>>>>[!example] присваеваем в перменную, но без вызова - `undefined`
>>>>```javascript
>>>>const a = person.sayHello
>>>console.log(a()) // "Hello, my name is undefined"
>>>>```
>>>Здесь мы присваиваем функцию `person.sayHello` переменной `a` без вызова. Когда мы затем вызываем `a()`, это происходит в глобальном контексте (или в контексте `undefined` в строгом режиме). `this` внутри функции не ссылается на `person`, поэтому `this.name` становится `undefined`.
>>>
>>>>[!example] присваеваем в перменную и вызываем
>>>>```javascript
>>>>const b = person.sayHello()
>>>>console.log(b) // "Hello, my name is John"
>>>>```
>>>Здесь мы вызываем `person.sayHello()` сразу при присваивании. Функция выполняется в контексте объекта `person`, возвращает строку, и эта строка присваивается переменной `b`.
>>5. **`this` внутри внешнего API**:
>>>[!example] пример с `setTimeout` (это внешнее апи бразуера или ноды)
>>>```javascript
>>>const person ={
>>>  name:'Abdul',
>>>  greet: function(){
>>>    console.log(this) // window если браузер
>>>    console.log('Hello, my name is '+ this.name ) // Hello, my name is undefined
>>>  }
>>>}
>>>
>>>setTimeout(person.greet,100) 
>>>```
>>>
>>>Внешнее ***API***(пример `setTimeout`) имеет право устанавливать `this` как ему хочется в том случае, когда это допустимо ***спецификацией***.
А в ***спецификации*** это допустимо только при вызове `regular function`(не стрелочной) для котрой `this` не был установлен любым другим явным методом типо [`call bind apply`](#call-bind-apply)
>>>>[!info]- ссылка и место где это укащано в HTML5 спецификации
>>>>[ссылка](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers)
>>>>To perform the timer initialization steps, given a WindowOrWorkerGlobalScope global, a string or Function or TrustedScript handler, a number timeout, a list arguments, a boolean repeat, and optionally (and only if repeat is true) a number previousId, perform the following steps. They return a number.
>>>>1. ***Let thisArg be global if that is a WorkerGlobalScope object; otherwise let thisArg be the WindowProxy that corresponds to global.***
>>
> ###### Как понять что в `this`:
>>![[Pasted image 20240913123330.png]]

# call-bind-apply
> [!help] 
>>[!quote]
>>**call**, **bind** и **apply** - это методы в JS, которые позволяют манипулировать контекстом выполнения функции ([`this`](#this)) и передавать аргументы.
>---
>>>[!quote] **call()**
>>>**call()** вызывает функцию с заданным значением [`this`](#this) и индивидуально предоставленными аргументами.
>>Синтаксис: `function.call(thisArg, arg1, arg2, ...)`
>>
>>>[!example] 
>>>```js 
>>>const person = {
>>>    fullName: function(city, country) {
>>>        console.log(this.firstName + " " + this.lastName + " lives in " + city + ", " + country);
>>>    }
>>>}
>>>
>>>const person1 = {
>>>    firstName:"John",
>>>    lastName: "Doe"
>>>}
>>>
>>>person.fullName.call(person1, "New York", "USA");
>>>// Выведет: John Doe lives in New York, USA
>>>```
>>> В этом примере мы используем **call**, чтобы выполнить метод `fullName` объекта `person` в контексте объекта `person1`.
>>
>---
>>>[!quote] **apply()**
>>>**apply()** похож на **call()**, но принимает аргументы как массив.
>>>Синтаксис: `function.apply(thisArg, [argsArray])`
>>
>>>[!example] 
>>>```js 
>>>const person = {
>>>    introduce: function(greeting, punctuation) {
>>>        return greeting + ", I'm " + this.name + punctuation;
>>>    }
>>>};
>>>
>>>const john = { name: "John" };
>>>const mary = { name: "Mary" };
>>>
>>>console.log(person.introduce.apply(john, ["Hello", "!"])); // Выведет: "Hello, I'm John!"
>>>console.log(person.introduce.apply(mary, ["Hi", "?"])); // Выведет: "Hi, I'm Mary?"
>>>```
>>> Здесь **apply** позволяет нам использовать метод `introduce` с разными объектами, передавая аргументы в виде массива.
>>
>---
>>>[!quote] **bind()**
>>>**bind()** создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение.
>>>Синтаксис: `function.bind(thisArg, arg1, arg2, ...)`
>>>>[!info] Описание
>>>>Метод `bind()` создаёт новую ***"привязанную функцию"*** (ПФ). ПФ - это необычный функциональный объект ( термин из ECMAScript 6 ), который является обёрткой над исходным функциональным объектом. ***Вызов ПФ приводит к исполнению кода обёрнутой функции***.
>>
>>>[!example] 
>>>```js 
>>>const user = {
>>>    name: "Alice",
>>>    sayHello: function() {
>>>        console.log("Hello, I'm " + this.name);
>>>    }
>>>};
>>>
>>>const sayHelloFunc = user.sayHello;
>>>sayHelloFunc(); // Выведет: "Hello, I'm undefined"
>>>
>>>const boundSayHello = user.sayHello.bind(user);
>>>boundSayHello(); // Выведет: "Hello, I'm Alice"
>>>```
>>>В этом примере **bind** создает новую функцию с привязанным контекстом, что особенно полезно при передаче методов в качестве колбэков.
>>
>>>[!example] Примеры посложнее (последний пример самый адекватный!!!)
>>>```js 
>>>function greet(greeting, punctuation, time) {
>>>    console.log(`${greeting}, ${this.name}${punctuation} It's ${time}.`);
>>>}
>>>
>>>const person = { name: 'John' };
>>>
>>>// Привязываем контекст и один аргумент
>>>const boundGreet1 = greet.bind(person, 'Hello');
>>>boundGreet1('!', 'morning'); // Выводит: "Hello, John! It's morning."
>>>
>>>// Привязываем контекст и два аргумента
>>>const boundGreet2 = greet.bind(person, 'Hi', '.');
>>>boundGreet2('evening'); // Выводит: "Hi, John. It's evening."
>>>
>>>// Привязываем только контекст  ЧТО ВЫГЛЯДЕТ СУПЕР АДЕКВАТНО(сразу аргмуенты уже в фукнциию с баиндом)
>>>const boundGreet3 = greet.bind(person);
>>>boundGreet3('Hey', '?', 'night'); // Выводит: "Hey, John? It's night."
>>>```
>>>
>###### Основные различия:
>> - `call` и `apply` немедленно вызывают функцию, в то время как `bind` возвращает новую функцию.
>> - `call` принимает аргументы по отдельности, `apply` принимает их как массив.
>> - `bind` позволяет предустановить некоторые аргументы, создавая частично примененную функцию.
>###### Схематичное предствление написания
>> - **call**: `func.call(контекст, арг1, арг2, арг3, ...)`
>> - **apply**: `func.apply(контекст, [арг1, арг2, арг3, ...])`
>> - **bind**: `func.bind(контекст, [предустановленный_арг1, предустановленный_арг2, ...])`

# декораторы
> [!help] 
>>[!quote]
>>**Декоратор** —  это функция, которая принимает другую функцию и возвращает новую функцию, обычно с дополнительной функциональностью.
>>  - ***Основная идея декоратора*** - обернуть существующую функцию, не изменяя её код.
>###### Зачем нужны декораторы?
>>Они позволяют писать более чистый код, придерживаясь концепции композиции, и распространять единожды разработанную возможность на несколько функций и классов. Используя декораторы, вы сможете писать код, который проще отлаживать и сопровождать.
>>С декораторами код основной функции становится компактным, поскольку весь код, предназначенный для расширения ее возможностей, пишется за ее пределами. За счет декораторов можно добавлять в код новые возможности, не усложняя его.
>###### Схожесть декораторов на [Функции Высшего порядка](#функции-высшего-порядка)
>>Хотя декораторы часто реализуются как [функции высшего порядка](#функции-высшего-порядка), они представляют собой более специализированное применение этой концепции для конкретной цели модификации поведения.
>> 
>> *Более детальную разницу между декораторами и [функциями высшего порядка](#функции-высшего-порядка) можно посмотреть в [тут](#функции-высшего-порядка)*
>###### Примеры
>>[!example] Декоратор для логирования
>>```js 
>>function log(fn) {
>>  return function(...args) {
>>    console.log(`Вызвана функция: ${fn.name}`);
>>    return fn(...args);
>>  }
>>}
>>
>>function sayHello(name) {
>>  return `Привет, ${name}!`;
>>}
>>
>>const loggedSayHello = log(sayHello);
>>
>>console.log(loggedSayHello("Алиса"));
>>// Выведет:
>>// Вызвана функция: sayHello
>>// Привет, Алиса!
>>```
>>Здесь мы используем `...args` (оператор [`rest`](#rest-spread)), потому что:
>> - Мы хотим, чтобы декоратор `log` был универсальным и работал с любой функцией, независимо от количества аргументов.
>> - `...args` собирает все переданные аргументы в массив.
>> - Затем мы используем `fn(...args)` (оператор [`spread`](#rest-spread)), чтобы передать все эти аргументы в исходную функцию.
>> - Это позволяет декоратору `log` работать с функциями, принимающими любое количество аргументов, не зная заранее, сколько их будет.
>
>>[!example] Декоратор для проверки типов
>>```js 
>>function checkNumber(fn) {
>>  return function(x) {
>>    if (typeof x !== 'number') {
>>      throw new Error('Аргумент должен быть числом');
>>    }
>>    return fn(x);
>>  }
>>}
>>
>>function square(x) {
>>  return x * x;
>>}
>>
>>const checkedSquare = checkNumber(square);
>>
>>console.log(checkedSquare(5)); // 25
>>// checkedSquare("не число"); // Выбросит ошибку
>>```
>> Здесь мы используем `x`, потому что:
>> - Этот декоратор предназначен специально для функций, принимающих один числовой аргумент.
>> - Мы точно знаем, что проверяем и передаем только один аргумент.
>> - Использование конкретного параметра `x` делает код более читаемым и явно указывает на то, что ожидается только один аргумент.
> 
>>[!example] Декоратор для задержки выполнения
>>```js 
>>function delay(fn, ms) {
>>  return function(...args) {
>>    setTimeout(() => {
>>      fn(...args);
>>    }, ms);
>>  }
>>}
>>
>>function greet(name) {
>>  console.log(`Привет, ${name}!`);
>>}
>>
>>const delayedGreet = delay(greet, 1000);
>>
>>delayedGreet("Боб"); // "Привет, Боб!" после 1 секунды
>>```
> 
>>[!example] Декоратор для однократного выполнения
>>```js 
>>function once(fn) {
>>  let called = false;
>>  let result;
>>
>>  return function(...args) {
>>    if (!called) {
>>      result = fn(...args);
>>      called = true;
>>    }
>>    return result;
>>  }
>>}
>>
>>function initApp() {
>>  console.log("Приложение инициализировано");
>>}
>>
>>const initOnce = once(initApp);
>>
>>initOnce(); // "Приложение инициализировано"
>>initOnce(); // (ничего не выводит)
>>initOnce(); // (ничего не выводит)
>>```
> ###### Выбор между `...args` и `конкретным параметром` зависит от:
>> - ***Универсальности декоратора***: Нужно ли, чтобы он работал с функциями, принимающими разное количество аргументов?
>> - ***Специфики задачи***: Если декоратор предназначен для конкретного типа функций (например, с одним аргументом), можно использовать конкретный параметр.
>> - ***Читаемости кода***: Иногда явное указание параметров делает код более понятным.
>>
>>В общем случае, если вы хотите создать универсальный декоратор, который может работать с любыми функциями, используйте `...args`. Если декоратор предназначен для функций с определенным количеством аргументов, можно использовать конкретные параметры.
>


# композиция-функций-(compose)
> [!help] 
>>[!quote]
> **Композиция функций** позволяет объединять две (или более) функции в одну новую функцию. Используется для упрощения цепочек вызовов и создания новых функций из существующих.
>>
> Схоже на [декоратор](#декораторы), но не добавляют какую-либо функциональность как это делает [декоратор](#декораторы).
>
>>[!example]
>> ```js
>> const add = x => x + 1;
>>const double = x => x * 2;
>>
>>const compose = (f, g) => (x) => f(g(x));
>>
>>const composedFunction = compose(add, double);
>>console.log(composedFunction(3)); // 7 (сначала double(3) = 6, затем add(6) = 7)
>>```
>
>>[!example]
>> ```js
>> const x = (x) => x * 2
>> const y = (x) => x * 2
>> const z = (x) => x * 2
>> 
>> const compose =(x,y,z)=>{
>>   return function(num){
>>     return x(y(z(num)))
 >>  }
>> }
>> 
>> console.log(compose(x,y,z)(2)) //16
>>```
>>
>>  ** Основная идея** - `compose(f, g)` возвращает функцию, которая сначала вызывает `g(x)`, а потом передает результат в `f`.



# функции-высшего-порядка
> [!help] 
>>[!quote] 
>> **Функции высшего порядка** (ФВП) - функции, которые принимают другие функции как аргументы или возвращают функции.
>>
>> ***Цель***: Абстрагирование и обобщение операций над функциями.
>>
>>***Примеры использования***:
>> - `Array.map()` - применяет функцию к каждому элементу массива.
>> - `setTimeout()` - принимает функцию для выполнения через определенное время.
>> - `Promise.then()` - принимает функции для обработки результата асинхронной операции.
>
>>[!example]  функция для дебоунсинга, которая широко используется для оптимизации производительности в веб-приложениях.
>>```js 
>>function debounce(func, delay) {
>>    let timeoutId;
>>    
>>    return function(...args) {
>>        clearTimeout(timeoutId);
>>        
>>        timeoutId = setTimeout(() => {
>>            func(...args);
>>        }, delay);
>>    };
>>}
>>
>>// Остальной код остается без изменений
>>function handleSearch(query) {
>>    console.log(`Выполняется поиск для: ${query}`);
>>    // Здесь мог бы быть API-запрос
>>}
>>
>>const debouncedSearch = debounce(handleSearch, 300);
>>
>>// Имитация ввода пользователя
>>debouncedSearch("a");
>>debouncedSearch("ap");
>>debouncedSearch("app");
>>debouncedSearch("appl");
>>debouncedSearch("apple");
>>
>>// Только последний вызов "apple" будет выполнен после 300 мс
>>```
>
>###### Ключевые различия между [ДЕКОРАТОРАМИ](#декораторы) и ФВП
>>1. ***Назначение***:
>>      - Функции высшего порядка: общий инструмент для работы с функциями как с данными.
>>      - [Декораторы](#декораторы): специфический паттерн для изменения поведения функций или объектов.
>>2. ***Гибкость***:
>>      - Функции высшего порядка: могут выполнять широкий спектр операций с функциями.
>>      - [Декораторы](#декораторы): фокусируются на обертывании и модификации существующего поведения.
>>3. ***Контекст использования***:
>>      - Функции высшего порядка: часто используются в функциональном программировании для композиции и абстракции.
>>      - [Декораторы](#декораторы): чаще применяются в объектно-ориентированном дизайне для расширения функциональности.
>>4. ***Структура***:
>>      - Функции высшего порядка: могут принимать или возвращать функции в различных комбинациях.
>>      - [Декораторы](#декораторы): обычно следуют конкретной структуре – принимают функцию и возвращают новую функцию с дополнительным поведением.
>>
>>В итоге, хотя [декораторы](#декораторы) часто реализуются как функции высшего порядка, они представляют собой более специализированное применение этой концепции для конкретной цели модификации поведения.

# rest-spread
> [!help] 
>>>[!quote] **Rest(...)**
>>>**Rest(...)** оператор позволяет собрать несколько элементов в массив. Он используется в параметрах функций или в деструктуризации.
>> ###### Примеры
>>>[!example] В параметрах функции
>>>```js 
>>>function sum(...numbers) {
>>>  return numbers.reduce((total, num) => total + num, 0);
>>>}
>>>
>>>console.log(sum(1, 2, 3, 4)); // 10
>>>console.log(sum(5, 10, 15)); // 30
>>>```
>>
>>>[!example] В деструктуризации массива
>>>```js
>>>const [first, second, ...rest] = [1, 2, 3, 4, 5];
>>>console.log(first); // 1
>>>console.log(second); // 2
>>>console.log(rest); // [3, 4, 5]
>>>``` 
>>
>>>[!example] В деструктуризации объекта:
>>>```js
>>>const {name, age, ...otherInfo} = {name: "Алиса", age: 30, city: "Минск", job: "Программист"};
>>>console.log(name); // "Алиса"
>>>console.log(age); // 30
>>>console.log(otherInfo); // {city: "Минск", job: "Программист"}
>>>```
> ---
>>>[!quote] **Spread(...)**
>>>**Spread(...)** оператор "разворачивает" массив или объект на отдельные элементы. Он используется при вызове функций, создании новых массивов или объектов.** 
>> ###### Примеры
>>>[!example] При вызове функции
>>>```js
>>>function greet(first, second, third) {
>>>  console.log(`Привет, ${first}, ${second} и ${third}!`);
>>>}
>>>
>>>const names = ["Алиса", "Боб", "Чарли"];
>>>greet(...names); // "Привет, Алиса, Боб и Чарли!"
>>>``` 
>>
>>>[!example] При создании нового массива
>>>```js
>>>const arr1 = [1, 2, 3];
>>>const arr2 = [4, 5, 6];
>>>const combined = [...arr1, ...arr2];
>>>console.log(combined); // [1, 2, 3, 4, 5, 6]
>>>``` 
>>
>>>[!example] При создании копии массива
>>>```js
>>>const original = [1, 2, 3];
>>>const copy = [...original];
>>>console.log(copy); // [1, 2, 3]
>>>``` 
>>
>>>[!example] При работе с объектами
>>>```js
>>>const obj1 = {a: 1, b: 2};
>>>const obj2 = {c: 3, d: 4};
>>>const merged = {...obj1, ...obj2};
>>>console.log(merged); // {a: 1, b: 2, c: 3, d: 4}
>>>``` 
>>
>>>[!example] Для создания нового объекта с изменениями
>>>```js
>>>const person = {name: "Алиса", age: 30};
>>>const updatedPerson = {...person, age: 31};
>>>console.log(updatedPerson); // {name: "Алиса", age: 31}
>>>``` 

# строгое-и-нестрогое-равенсто
> [!help] 
>>[!quote] **==**
>>**Оператор == (нестрогое равенство)**
>> - Сравнивает значения с приведением типов.
>> - Если типы операндов различаются, JavaScript пытается привести их к общему типу перед сравнением.
>
>>[!quote] **===**
>>**Оператор === (строгое равенство)**
>> - Сравнивает значения без приведения типов.
>> - Возвращает `true` только если операнды имеют одинаковый тип и одинаковое значение.
>
>>[!example] Примеры
>>```js
>>// Сравнение чисел
>>console.log(5 == 5);   // true
>>console.log(5 === 5);  // true
>>
>>// Сравнение числа и строки
>>console.log(5 == "5");   // true (строка "5" приводится к числу 5)
>>console.log(5 === "5");  // false (разные типы)
>>
>>// Сравнение с булевыми значениями
>>console.log(1 == true);   // true (true приводится к 1)
>>console.log(1 === true);  // false (разные типы)
>>
>>// Сравнение с null и undefined
>>console.log(null == undefined);   // true
>>console.log(null === undefined);  // false
>>
>>// Сравнение объектов
>>let obj1 = {a: 1};
>>let obj2 = {a: 1};
>>let obj3 = obj1;
>>console.log(obj1 == obj2);   // false (разные объекты)
>>console.log(obj1 === obj2);  // false (разные объекты)
>>console.log(obj1 == obj3);   // true (тот же самый объект)
>>console.log(obj1 === obj3);  // true (тот же самый объект)
>>
>>// Особые случаи
>>console.log(0 == false);   // true
>>console.log(0 === false);  // false
>>console.log('' == false);  // true
>>console.log('' === false); // false
>>```
# логические-операторы
> [!help] 
>>[!quote] **Логические операторы в JS**
>> ***(Расположены по приоритету)*** 
>> - **!** (НЕ)
>> - **&&** (И)
>> - **||** (ИЛИ)
>> - **??** (Оператор нулевого слияния)
>
>>[!note] **Порядок приоритета операторов** (от высшего к низшему):
>> 1. **()** (скобки)
>> 2. **!** (логическое НЕ)
>> 3. ***, /, %** (умножение, деление, остаток)
>> 4. **+**, **-** (сложение, вычитание)
>> 5. **<**, **<=**, **>**, **>** **=** (сравнения)
>> 6. **==**, **!=**, **===**, **!==** (равенство/неравенство)
>> 7. **&&** (логическое И)
>> 8. **||** (логическое ИЛИ)
>> 9. **??** (оператор нулевого слияния)
>
>###### ! (НЕ)
>>>[!quote]
>>> - **Инвертирует булево значение операнда.**
>>> - **Приводит значение к булеву типу, затем инвертирует его.**
>>```js 
>>console.log(!true);  // false
>>console.log(!false);  // true
>>console.log(!0);  // true
>>console.log(!'');  // true
>>console.log(!1);  // false
>>console.log(!'hello');  // false
>>```
>
>###### && (И)
>>>[!quote]
>>> - **Возвращает `true`, если оба операнда истинны.**
>>> - **Возвращает первое ложное значение или последний операнд, если все истинны.**
>>```js 
>>console.log(true && true);  // true
>>console.log(true && false);  // false
>>console.log(false && true);  // false
>>console.log(false && false);  // false
>>console.log(1 && 2);  // 2
>>console.log(0 && 1);  // 0
>>console.log('a' && 'b');  // 'b'
>>console.log('' && 'b');  // ''
>>```
>
>###### || (ИЛИ)
>>>[!quote]
>>> - **Возвращает `true`, если хотя бы один операнд истинен.**
>>> - **Возвращает первое истинное значение или последний операнд, если все ложны.**
>>```js 
>>console.log(true || true);  // true
>>console.log(true || false);  // true
>>console.log(false || true);  // true
>>console.log(false || false);  // false
>>console.log(1 || 2);  // 1
>>console.log(0 || 1);  // 1
>>console.log('' || 'b');  // 'b'
>>console.log(null || undefined);  // undefined
>
>###### ?? (Оператор нулевого слияния)
>>>[!quote]
>>> - **Возвращает правый операнд, если левый операнд `null` или `undefined`.**
>>> - **В противном случае возвращает левый операнд.**
>>```js 
>>console.log(null ?? 'default');  // 'default'
>>console.log(undefined ?? 'default');  // 'default'
>>console.log(0 ?? 'default');  // 0
>>console.log('' ?? 'default');  // ''
>>console.log(false ?? 'default');  // false
>
>>[!info] Важно отметить
>> - Операторы **&&** и **||** используют короткозамкнутое вычисление. Это означает, что если результат может быть определен по первому операнду, второй операнд не вычисляется.
>> - Оператор **??** был добавлен в ECMAScript 2020 и может не поддерживаться в старых браузерах.
>> - При использовании нескольких операторов рекомендуется использовать скобки для явного указания порядка выполнения операций.
>###### Примеры
>>[!example] 
>>```js 
>>console.log(true && false || true && !false && (!true || false) && !(false || !true));
>>``` 
>>Разберем по шагам:
>>1. `!false = true`
>>2. `!true = false`
>>3. `(false || !true) = (false || false) = false`
>>4. `!(false || !true) = !false = true`
>>5. `true && false = false`
>>6. `true && true = true`
>>7. `false || true = true`
>>8. `true && false = false`
>>9. `false && true = false`
>>
>>Итоговый результат: ***false***
>
>>[!example] 
>>```js 
>>let a = 5, b = 10, c = 15;
>>console.log((a > b || b < c) && !(a > c) && (b - a > a - c || c % a === 0));
>>``` 
>>Разберем по шагам:
>>1. `a > b = false (5 > 10)`
>>2. `b < c = true (10 < 15)`
>>3. `(a > b || b < c) = (false || true) = true`
>>4. `a > c = false (5 > 15)`
>>5. `!(a > c) = !false = true`
>>6. `b - a = 5, a - c = -10`
>>7. `b - a > a - c = true (5 > -10)`
>>8. `c % a = 0 (15 % 5 = 0)`
>>9. `(b - a > a - c || c % a === 0) = (true || true) = true`
>>10. `true && true && true = true`
>>
>>Итоговый результат: ***true***
>
>>[!example] 
>>```js 
>>let x = null, y = undefined, z = '';
>>console.log((!x && y) || (z ?? 'default') !== '' && typeof x === typeof y);
>>```
>>Разберем по шагам:
>>
>>1. `!x = true (так как x = null)`
>>2. `(!x && y) = (true && undefined) = undefined`
>>3. `(z ?? 'default') = '' (так как z - пустая строка, а не null или undefined)`
>>4. `'' !== '' = false`
>>5. `typeof x = 'object' (в JS null имеет тип 'object')`
>>6. `typeof y = 'undefined'`
>>7. `typeof x === typeof y = false`
>>8. `false && false = false`
>>9. `undefined || false = false`
>>
>> Итоговый результат: ***false***
# typeof-разных-типов-данных
> [!help] 
>>[!quote] **Основные типы данных и результаты typeof**
>>```js 
>>console.log(typeof undefined);     // "undefined"
>>console.log(typeof null);          // "object"
>>console.log(typeof true);          // "boolean"
>>console.log(typeof 42);            // "number"
>>console.log(typeof "hello");       // "string"
>>console.log(typeof Symbol());      // "symbol"
>>console.log(typeof function(){});  // "function"
>>console.log(typeof {});            // "object"
>>console.log(typeof []);            // "object"
>>console.log(typeof NaN);           // "number"
>>console.log(typeof new Number(42));// "object"
>>```
###### Подводные камни и особенности:
>>[!info] **null**
>>```js 
>>console.log(typeof null);  // "object"
>>```
>>Это известная ошибка в JS, которая существует с самого начала. `null` не является объектом, но `typeof null` возвращает `"object"`. Это считается багом языка, который не может быть исправлен из-за обратной совместимости.
>
>>[!info] **Массивы**
>>```js 
>>console.log(typeof []);  // "object"
>>```
>>Массивы - это объекты, поэтому `typeof` возвращает `"object"`. Чтобы проверить, является ли что-то массивом, используйте `Array.isArray([])`
>>
>>```js 
>>console.log(Array.isArray([]));  // true
>>```
>
>>[!info] **NaN**
>>```js 
>>console.log(typeof NaN);  // "number"
>>```
>>`NaN` (Not a Number) парадоксально имеет тип `"number"`. Чтобы проверить на `NaN`, используйте `isNaN(NaN)`
>>```js 
>>console.log(isNaN(NaN));  // true
>>```
>
>>[!info] **Функции**
>>```js 
>>console.log(typeof function(){});  // "function"
>>```
>>Несмотря на то, что функции в JS являются объектами, `typeof` возвращает `"function"`.
>
>>[!info] **BigInt**
>>```js 
>>console.log(typeof 1n);  // "bigint"
>>```
>>BigInt - это относительно новый тип данных в JavaScript для работы с большими целыми числами.
>>
>
>>[!info] **Объекты-обертки**
>>```js 
>>console.log(typeof new Number(42));   // "object"
>>console.log(typeof new String("hi")); // "object"
>>console.log(typeof new Boolean(true));// "object"
>>```
>>Использование конструкторов создает объекты-обертки, а не примитивы.
>
>>[!info] **Неопределенные переменные**
>>```js 
>>console.log(typeof undeclaredVariable);  // "undefined"
>>```
>>`typeof` не вызывает ошибку для необъявленных переменных, что может быть полезно для проверки существования переменных.
>
>>[!info] **document** и **window**
>>```js 
>>console.log(typeof document);  // "object"
>>console.log(typeof window);    // "object"
>>```
>>Эти глобальные объекты браузера также имеют тип `"object"`.

# неявное-привидене-типов
> [!help] 
>>[!info] **undefined**
>>```js 
>>console.log(4 * undefined);  // NaN
>>console.log(4 + undefined);  // NaN
>>console.log(4 - undefined);  // NaN
>>console.log(4 / undefined);  // NaN
>>console.log(4 ** undefined); // NaN
>>console.log('4' + undefined); //4undefined
>>console.log('4' - undefined); //NaN
>>```
>>При арифметических операциях `undefined` преобразуется в `NaN`, что делает результат любой операции `NaN`.
>
>>[!info] **null**
>>```js 
>>console.log(4 * null);  // 0
>>console.log(4 + null);  // 4
>>console.log(4 - null);  // 4
>>console.log(4 / null);  // Infinity
>>console.log(4 ** null); // 1
>>console.log('4' + null);  // 4null
>>console.log('4' - null);  // 4
>>```
>>В арифметических операциях `null` преобразуется в `0`, кроме операции сложения, где он преобразуется в строку.
>
>>[!info] **Операции со строками**
>>```js
>>console.log("4" * 2);     // 8
>>console.log("4" + 2);     // "42"
>>console.log("4" - 2);     // 2
>>console.log("4" / 2);     // 2
>>console.log("4" ** 2);    // 16
>>console.log("hello" * 2); // NaN
>>```
>>JS пытается преобразовать `строки` в `числа`, когда это возможно. При сложении строка имеет приоритет, и происходит конкатенация.
>
>>[!info] **Операции с булевыми значениями**
>>```js
>>console.log(true + 1);        // 2
>>console.log(false + 1);       // 1
>>console.log(true * 5);        // 5
>>console.log(false * 5);       // 0
>>console.log(false * undefined); //NaN
>>console.log(false - undefined); //NaN
>>console.log(true + '1');         //true1
>>```
>>`true` преобразуется в `1`, `false` - в `0`.
>
>>[!info] **Операции с NaN**
>>```js
>>console.log(NaN + 1);  // NaN
>>console.log(NaN * 2);  // NaN
>>console.log(NaN / 3);  // NaN
>>console.log(NaN ** 0); // 1 (любое число в степени 0 равно 1)
>>```
>>Любая арифметическая операция с `NaN` дает `NaN`, кроме возведения в степень `0`.
>
>>[!info] **Операции с Infinity**
>>```js
>>console.log(Infinity + 1);  // Infinity
>>console.log(Infinity * 2);  // Infinity
>>console.log(Infinity / 3);  // Infinity
>>console.log(Infinity - Infinity); // NaN
>>console.log(Infinity / Infinity); // NaN
>>```
>
>>[!info] **Смешанные операции**
>>```js
>>console.log([] + {});     // "[object Object]"
>>console.log({} + []);     // 0 (в некоторых браузерах) или "[object Object]"
>>console.log([] + []);     // ""
>>console.log({} + {});     // "[object Object][object Object]"
>>console.log([] == !{});   // true
>>console.log([] == false); // true
>>console.log(!!{});        // true
>>console.log(!!0);         // false
>>```
>
>>[!info] **Операции с объектами**
>>```js
>>console.log({} + 1);        // "[object Object]1"
>>console.log([1,2,3] + 4);   // "1,2,34"
>>console.log([1] - 1);       // 0
>>console.log([1,2] - 1);     // NaN
>>```
>>1. `console.log([1,2,3] + 4);   // "1,2,34"`
>>      - ***Почему так***: Когда оператор `+` используется с `массивом`, JS сначала преобразует ***массив в строку***. Метод преобразования массива в строку соединяет все элементы через запятую. Таким образом, `[1,2,3]` становится строкой `"1,2,3"`. Затем происходит конкатенация этой строки с числом `4`, которое тоже преобразуется в строку. 
>>      - **Результат**: `"1,2,3"` + `"4"` = `"1,2,34"`.
>>
>>2. `console.log([1] - 1);       // 0`
>>      - ***Почему так***: При использовании оператора `-`, JS пытается преобразовать операнды в числа. Массив с одним числовым элементом `[1]` преобразуется в число `1`. Таким образом, операция становится эквивалентной `1` - `1`, что равно `0`.
>>
>>3. `console.log([1,2] - 1);     // NaN`
>>      - ***Почему так***: Здесь JS также пытается преобразовать ***массив в число***, но массив с более чем одним элементом не может быть напрямую преобразован в число. Попытка преобразования `[1,2]` в число дает `NaN`. Любая арифметическая операция с `NaN` всегда дает `NaN`.
>
>>Важно помнить, что многие из этих операций основаны на неявном приведении типов в JS. Хотя некоторые из них могут показаться нелогичными, они следуют определенным правилам языка. В профессиональной разработке рекомендуется избегать полагаться на такие неявные преобразования и использовать явное приведение типов для улучшения читаемости и предсказуемости кода.
# создание-массива
> [!help] 
>>[!info] **Array.from()**
>>Создает новый массив из массивоподобного или итерируемого объекта
>>```js
>>let arrayFromString = Array.from('hello');
>>console.log(arrayFromString); // ['h', 'e', 'l', 'l', 'o']
>>
>>let arrayFromSet = Array.from(new Set([1, 2, 3, 2, 1]));
>>console.log(arrayFromSet); // [1, 2, 3]
>>
>>let arrayWithMap = Array.from([1, 2, 3], x => x * 2);
>>console.log(arrayWithMap); // [2, 4, 6]
>>```
>
>>[!info] **Заполнение массива**
>>Создание и заполнение массива значениями
>>```js
>>let filledArray = new Array(3).fill('a');
>>console.log(filledArray); // ['a', 'a', 'a']
>>
>>let numberedArray = Array.from({length: 5}, (_, i) => i + 1);
>>console.log(numberedArray); // [1, 2, 3, 4, 5]
>>```
>
>>[!info] **Spread оператор**
>>Раскрывает итерируемый объект в список элементов
>>```js
>>let arr1 = [1, 2, 3];
>>let arr2 = [...arr1, 4, 5];
>>console.log(arr2); // [1, 2, 3, 4, 5]
>>
>>let arrFromString = [...'hello'];
>>console.log(arrFromString); // ['h', 'e', 'l', 'l', 'o']
>>```
>
>>[!info] **Array.prototype.slice()**
>>Создает новый массив, копируя часть существующего
>>```js
>>let original = [1, 2, 3, 4, 5];
>>let copy = original.slice();
>>console.log(copy); // [1, 2, 3, 4, 5]
>>
>>let partial = original.slice(1, 4);
>>console.log(partial); // [2, 3, 4]
>>```
# методы-массива
> [!help] 
>>[!info]- **push()**
>> - Добавляет элементы в конец массива
>> - Изменяет исходный массив
>> - Возвращает новую длину массива
>>```js
>>let arr = [1, 2];
>>let length = arr.push(3, 4);
>>console.log(arr);    // [1, 2, 3, 4]
>>console.log(length); // 4
>>```
>
>>[!info]- **pop()**
>> - Удаляет последний элемент из массива
>> - Изменяет исходный массив
>> - Возвращает удаленный элемент
>>```js
>>let arr = [1, 2, 3];
>>let last = arr.pop();
>>console.log(arr);  // [1, 2]
>>console.log(last); // 3
>>```
>
>>[!info]- **unshift()**
>> - Добавляет элементы в начало массива
>> - Изменяет исходный массив
>> - Возвращает новую длину массива
>>```js
>>let arr = [2, 3];
>>let length = arr.unshift(0, 1);
>>console.log(arr);    // [0, 1, 2, 3]
>>console.log(length); // 4
>>```
>
>>[!info]- **shift()**
>> - Удаляет первый элемент из массива
>> - Изменяет исходный массив
>> - Возвращает удаленный элемент
>>```js
>>let arr = [1, 2, 3];
>>let first = arr.shift();
>>console.log(arr);   // [2, 3]
>>console.log(first); // 1
>>```
>
>>[!info]- **flat()**
>>  - Разворачивает вложенные массивы в один уровень
>>  - Не изменяет исходный массив
>>  - Возвращает новый массив с развернутыми подмассивами
>>```js
>>let arr = [1, 2, [3, 4, [5, 6]]];
>>let flattened = arr.flat();
>>console.log(flattened); // [1, 2, 3, 4, [5, 6]]
>>
>>// С указанием глубины разворачивания
>>let deepFlattened = arr.flat(2);
>>console.log(deepFlattened); // [1, 2, 3, 4, 5, 6]
>>
>>// Полное разворачивание всех уровней
>>let completelyFlat = arr.flat(Infinity);
>>console.log(completelyFlat); // [1, 2, 3, 4, 5, 6]
>>```
>
>>[!info]- **concat()**
>> - Объединяет два или более массивов
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr1 = [1, 2];
>>let arr2 = [3, 4];
>>let newArr = arr1.concat(arr2);
>>console.log(newArr); // [1, 2, 3, 4]
>>console.log(arr1);   // [1, 2]
>>```
>
>>[!info]- **slice()**
>> - Возвращает часть массива
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let newArr = arr.slice(1, 4);
>>console.log(newArr); // [2, 3, 4]
>>console.log(arr);    // [1, 2, 3, 4, 5]
>>```
>
>>[!info]- **splice()**
>> - Изменяет содержимое массива, удаляя/заменяя существующие элементы и/или добавляя новые
>> - Изменяет исходный массив
>> - Возвращает массив удаленных элементов
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let removed = arr.splice(1, 2, 'a', 'b');
>>console.log(arr);     // [1, 'a', 'b', 4, 5]
>>console.log(removed); // [2, 3]
>>```
>>
>>>[!info] Возможности 
>>>```js
>>>splice(start, deleteCount, item1, item2, ...)
>>>```
>>>   - `start`: индекс, с которого начинать изменение
>>>   - `deleteCount`: количество элементов для удаления (необязательно)
>>>   - `item1, item2`, ...: элементы для добавления (необязательно)
>>>1. ***Добавление элементов***:
>>>>```js
>>>>let arr = [1, 2, 3];
>>>>arr.splice(1, 0, 'a', 'b');
>>>>console.log(arr); // [1, 'a', 'b', 2, 3]
>>>>```
>>>>Здесь мы добавляем `a` и `b` начиная с индекса `1`, не удаляя элементов.
>>>
>>>2. ***Замена элементов***:
>>>>```js
>>>>let arr = [1, 2, 3, 4];
>>>>arr.splice(1, 2, 'a', 'b');
>>>>console.log(arr); // [1, 'a', 'b', 4]
>>>>```
>>>>
>>>>Здесь мы заменяем `2` элемента начиная с индекса `1` на `a` и `b`.
>>>3. ***Удаление элементов***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>arr.splice(2, 2);
>>>>console.log(arr); // [1, 2, 5]
>>>>```
>>>>
>>>>Здесь мы удаляем `2` элемента начиная с индекса `2`.
>>>4. ***Удаление элементов до конца массива***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>arr.splice(2);
>>>>console.log(arr); // [1, 2]
>>>>```
>>>>
>>>>Если не указать `deleteCount`, удалятся все элементы от `start` до конца массива.
>>>5. ***Извлечение части массива без его изменения***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>let extracted = arr.splice(2, 2);
>>>>console.log(extracted); // [3, 4]
>>>>console.log(arr);       // [1, 2, 5]
>>>>```
>>>>`splice()` возвращает массив удаленных элементов.
>
>>[!info]- **forEach()**
>> - Выполняет функцию для каждого элемента массива
>> - Не изменяет исходный массив (если только функция не изменяет элементы)
>> - Возвращает `undefined`
>>```js
>>let arr = [1, 2, 3];
>>arr.forEach(item => console.log(item * 2));
>>// Выводит: 2, 4, 6
>>```
>
>>[!info]- **map()**
>> - Создает новый массив с результатами вызова функции для каждого элемента
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3];
>>let newArr = arr.map(item => item * 2);
>>console.log(newArr); // [2, 4, 6]
>>console.log(arr);    // [1, 2, 3]
>>```
>
>>[!info]- **filter()**
>> - Создает новый массив с элементами, прошедшими проверку
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let evenArr = arr.filter(item => item % 2 === 0);
>>console.log(evenArr); // [2, 4]
>>console.log(arr);     // [1, 2, 3, 4, 5]
>>```
>
>>[!info]- **reduce()**
>> - Выполняет функцию для каждого элемента массива (слева-направо), сводя его к одному значению
>> - Не изменяет исходный массив
>> - Возвращает одно значение
>>```js
>>let arr = [1, 2, 3, 4];
>>let sum = arr.reduce((acc, curr) => acc + curr, 0);
>>console.log(sum);  // 10
>>console.log(arr);  // [1, 2, 3, 4]
>>```
>
>>[!info]- **find()**
>> - Возвращает первый элемент, удовлетворяющий условию
>> - Не изменяет исходный массив
>> - Возвращает элемент или undefined
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let found = arr.find(item => item > 3);
>>console.log(found); // 4
>>```
>
>>[!info]- **some()**
>> - Проверяет, удовлетворяет ли хотя бы один элемент условию
>> - Не изменяет исходный массив
>> - Возвращает `boolean`
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let hasEven = arr.some(item => item % 2 === 0);
>>console.log(hasEven); // true
>>```
>
>>[!info]- **every()**
>> - Проверяет, удовлетворяют ли все элементы условию
>> - Не изменяет исходный массив
>> - Возвращает `boolean`
>>```js
>>let arr = [2, 4, 6, 8];
>>let allEven = arr.every(item => item % 2 === 0);
>>console.log(allEven); // true
>>```
>
>>[!info]- **reverse()**
>> - Обращает порядок элементов в массиве
>> - Изменяет исходный массив
>> - Возвращает измененный массив
>>```js
>>let arr = [1, 2, 3];
>>arr.reverse();
>>console.log(arr); // [3, 2, 1]
>>```
>
>>[!info]- **sort()**
>> - Сортирует элементы массива
>> - Изменяет исходный массив
>> - Возвращает отсортированный массив
>>```js
>>let arr = [3, 1, 4, 1, 5];
>>arr.sort((a, b) => a - b);
>>console.log(arr); // [1, 1, 3, 4, 5]
>>```
>
>>[!info]- **join()**
>> - Объединяет все элементы массива в строку
>> - Не изменяет исходный массив
>> - Возвращает строку
>>```js
>>let arr = ['Hello', 'World'];
>>let str = arr.join(' ');
>>console.log(str); // "Hello World"
>>```
>
>>[!info]- **indexOf()**
>>  - Ищет элемент в массиве и возвращает его индекс
>>  - Не изменяет исходный массив
>>  - Возвращает индекс первого найденного элемента или `-1`, если элемент не найден
>>```js
>>let arr = [1, 2, 3, 2, 1];
>>let index = arr.indexOf(2);
>>console.log(index); // 1
>>
>>let notFound = arr.indexOf(4);
>>console.log(notFound); // -1
>>
>>// Поиск с указанной позиции
>>let laterIndex = arr.indexOf(2, 2);
>>console.log(laterIndex); // 3
>>```
>
>>[!info]- **includes()**
>> - Проверяет, содержит ли массив указанное значение и возвращает `true` или `false`.
>> - Не изменяет исходный массив.
>> - Выполняет строгое сравнение (`===`) для указанного элемента.
>>```js
>>let arr = [1, 2, 3, 2, 1];
>>let result = arr.includes(2);
>>console.log(result); // true
>>
>>let notFound = arr.includes(4);
>>console.log(notFound); // false
>>
>>// Поиск с указанной позиции
>>let laterResult = arr.includes(2, 2);
>>console.log(laterResult); // true
>>
>>// Поиск с отрицательным индексом
>>let resultFromEnd = arr.includes(1, -1);
>>console.log(resultFromEnd); // false
>>```
# статические-методы-массива
> [!help] **Статические методы Array**
>>[!quote] 
>>Это методы, которые вызываются непосредственно на ***конструкторе*** `Array`, а не на экземплярах массива
>>Они не являются методами прототипа
>
>>**Основные статические методы `Array`**:
>>1. `Array.from()`
>>2. `Array.isArray()`
>>3. `Array.of()`
>
>>[!note] **Array.from()**
>> - Создает новый массив из массивоподобного или итерируемого объекта
>> - Часто используется для преобразования DOM-коллекций, строк или объектов в массивы
>>```js
>>// Преобразование строки в массив
>>let arr1 = Array.from('hello');
>>console.log(arr1); // ['h', 'e', 'l', 'l', 'o']
>>
>>// Преобразование Set в массив
>>let set = new Set([1, 2, 3, 2, 1]);
>>let arr2 = Array.from(set);
>>console.log(arr2); // [1, 2, 3]
>>
>>// Создание массива с использованием функции отображения
>>let arr3 = Array.from({length: 5}, (_, index) => index * 2);
>>console.log(arr3); // [0, 2, 4, 6, 8]
>>```
>
>>[!note] **Array.isArray()**
>> - Проверяет, является ли переданный аргумент массивом
>> - Возвращает true для массивов и false для всех остальных типов
>>```js
>>console.log(Array.isArray([1, 2, 3])); // true
>>console.log(Array.isArray('hello')); // false
>>console.log(Array.isArray(new Set())); // false
>>
>>// Полезно для проверки типа в функциях
>>function processArray(arr) {
>>    if (Array.isArray(arr)) {
>>        return arr.length;
>>    } else {
>>        return 'Argument is not an array';
>>    }
>>}
>>console.log(processArray([1, 2, 3])); // 3
>>console.log(processArray('hello')); // 'Argument is not an array'
>>```
>
>>[!note] **Array.of()**
>> - Создает новый массив с переменным числом аргументов
>> - Особенно полезен, когда нужно создать массив с одним элементом
>>```js
>>let arr1 = Array.of(7);
>>console.log(arr1); // [7]
>>
>>let arr2 = Array.of(1, 2, 3);
>>console.log(arr2); // [1, 2, 3]
>>
>>// Сравните с обычным конструктором Array:
>>let arr3 = new Array(7);
>>console.log(arr3); // [empty × 7]
>>
>>// Array.of() полезен в функциях с переменным числом аргументов
>>function createArray(...args) {
>>    return Array.of(...args);
>>}
>>console.log(createArray(1, 'two', {three: 3})); // [1, 'two', {three: 3}]
>>```
# методы-строк
> [!help] 
>>[!info]- **length**
>>Возвращает длину строки
>>Это свойство, а не метод
>>```js
>>let str = "Hello";
>>console.log(str.length); // 5
>>```
>
>>[!info]- **charAt()**
>>Возвращает символ по указанному индексу
>>```js
>>let str = "Hello";
>>console.log(str.charAt(1)); // "e"
>>```
>
>>[!info]- **charCodeAt()**
>>Возвращает Unicode символа по указанному индексу
>>```js
>>let str = "Hello";
>>console.log(str.charCodeAt(0)); // 72
>>```
>
>>[!info]- **concat()**
>>Объединяет две или более строки
>>```js
>>let str1 = "Hello";
>>let str2 = "World";
>>console.log(str1.concat(" ", str2)); // "Hello World"
>>```
>
>>[!info]- **indexOf()**
>>Возвращает индекс первого вхождения подстроки
>>```js
>>let str = "Hello World";
>>console.log(str.indexOf("World")); // 6
>>```
>
>>[!info]- **lastIndexOf()**
>>Возвращает индекс последнего вхождения подстроки
>>```js
>>let str = "Hello World World";
>>console.log(str.lastIndexOf("World")); // 12
>>```
>
>>[!info]- **slice()**
>>Извлекает часть строки и возвращает новую строку
>>```js
>>let str = "Hello World";
>>console.log(str.slice(6)); // "World"
>>console.log(str.slice(0, 5)); // "Hello"
>>```
>
>>[!info]- **substring()**
>>Извлекает символы между двумя индексами строки
>>```js
>>let str = "Hello World";
>>console.log(str.substring(6, 11)); // "World"
>>```
>
>>[!info]- **substr()**
>>Извлекает указанное количество символов с указанной позиции
>>```js
>>let str = "Hello World";
>>console.log(str.substr(6, 5)); // "World"
>>```
>
>>[!info]- **toLowerCase()**
>>Преобразует строку в нижний регистр
>>```js
>>let str = "Hello World";
>>console.log(str.toLowerCase()); // "hello world"
>>```
>
>>[!info]- **toUpperCase()**
>>Преобразует строку в верхний регистр
>>```js
>>let str = "Hello World";
>>console.log(str.toUpperCase()); // "HELLO WORLD"
>>```
>
>>[!info]- **trim()**
>>Удаляет пробельные символы с начала и конца строки
>>```js
>>let str = "  Hello World  ";
>>console.log(str.trim()); // "Hello World"
>>```
>
>>[!info]- **replace()**
>>Заменяет указанное значение другим значением в строке
>>```js
>>let str = "Hello World";
>>console.log(str.replace("World", "JavaScript")); // "Hello JavaScript"
>>```
>
>>[!info]- **split()**
>>Разбивает строку на массив подстрок
>>```js
>>let str = "Hello,World,JavaScript";
>>console.log(str.split(",")); // ["Hello", "World", "JavaScript"]
>>```
>
>>[!info]- **startsWith()**
>>Проверяет, начинается ли строка с указанных символов
>>```js
>>let str = "Hello World";
>>console.log(str.startsWith("Hello")); // true
>>```
>
>>[!info]- **endsWith()**
>>Проверяет, заканчивается ли строка указанными символами
>>```js
>>let str = "Hello World";
>>console.log(str.endsWith("World")); // true
>>```
>
>>[!info]- **includes()**
>>Проверяет, содержит ли строка указанную подстроку
>>```js
>>let str = "Hello World";
>>console.log(str.includes("World")); // true
>>```
>
>>[!info]- **repeat()**
>>Возвращает новую строку с указанным числом копий исходной строки
>>```js
>>let str = "Hello";
>>console.log(str.repeat(3)); // "HelloHelloHello"
>>```
>
>>[!info]- **padStart()**
>>Дополняет текущую строку другой строкой до заданной длины с начала
>>```js
>>let str = "5";
>>console.log(str.padStart(3, "0")); // "005"
>>```
>
>>[!info]- **padEnd()**
>>Дополняет текущую строку другой строкой до заданной длины с конца
>>```js
>>let str = "5";
>>console.log(str.padEnd(3, "0")); // "500"
>>```

# статические-методы-обьектов
>[!help]
>>[!info]- **Object.assign()**
>>Копирует значения всех перечисляемых свойств из одного или более исходных объектов в целевой объект
>>```js
>>const target = { a: 1, b: 2 };
>>const source = { b: 4, c: 5 };
>>const returnedTarget = Object.assign(target, source);
>>console.log(target); // { a: 1, b: 4, c: 5 }
>>```
>
>>[!info]- **Object.create()**
>>Создает новый объект с указанным прототипом и свойствами
>>```js
>>const person = {
>>    isHuman: false,
>>    printIntroduction: function() {
>>        console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
>>    }
>>};
>>const me = Object.create(person);
>>me.name = "Matthew";
>>me.isHuman = true;
>>me.printIntroduction(); // My name is Matthew. Am I human? true
>>```
>
>>[!info]- **Object.entries()**
>> - Возвращает массив собственных перечисляемых свойств указанного объекта в формате `[key, value]`
>>  - Противоположный ему метод это - `Object.fromEntries()` - преобразует список пар ключ-значение в объект
>>
>>***Проще говоря, массив массивов получается из объекта***
>>```js
>>const object1 = { a: 'somestring', b: 42 };
>>for (const [key, value] of Object.entries(object1)) {
>>    console.log(`${key}: ${value}`);
>>}
>>// "a: somestring"
>>// "b: 42"
>>```
>>###### Подробнее про `Object.entries()`
>>>1. ***Преобразование объекта в итерируемую структуру***:
>>>    - `Object.entries()` преобразует объект в массив пар `[ключ, значение]`, что действительно позволяет использовать методы массива для работы с данными объекта.
>>>2. ***Доступ к ключам и значениям одновременно***:
>>>    - В отличие от `Object.keys()` или `Object.values()`, `Object.entries()` дает доступ и к ключам, и к значениям одновременно, что удобно во многих ситуациях.
>>>3. ***Упрощение итерации***:
>>>    - Хотя можно использовать цикл `for...in` для перебора свойств объекта, `Object.entries()` предоставляет более структурированный способ работы с парами ключ-значение.
>>>4. ***Преобразование форматов данных***:
>>>    - Метод упрощает преобразование объектов в другие форматы данных и обратно (например, в `Map` или в массив).
>>>5. ***Деструктуризация***:
>>>    - Результат `Object.entries()` легко деструктурировать, что делает код более читаемым и лаконичным.
>>>
>>>>[!example] Пример, демонстрирующий несколько из этих аспектов:
>>>>```js 
>>>>const person = {
>>>>    name: "Alice",
>>>>    age: 30,
>>>>    city: "New York"
>>>>};
>>>>
>>>>// Преобразование и фильтрация
>>>>const adultInfo = Object.entries(person)//[ ['name','Alice'],['age',30],['city','New York'] ]
>>>>    .filter(([key, value]) => key !== 'age' || value >= 18)
>>>>    .map(([key, value]) => `${key}: ${value}`)
>>>>    .join(', ');
>>>>
>>>>console.log(adultInfo); // "name: Alice, age: 30, city: New York"
>>>>
>>>>// Преобразование в Map
>>>>const personMap = new Map(Object.entries(person));
>>>>console.log(personMap.get('name')); // "Alice"
>>>>
>>>>// Функциональное преобразование объекта
>>>>const upperCasePerson = Object.fromEntries(
>>>>    Object.entries(person).map(([key, value]) => [key.toUpperCase(), value])
>>>>);
>>>>console.log(upperCasePerson); // { NAME: "Alice", AGE: 30, CITY: "New York" }
>>>>```
>>###### Еще Примеры
>>>[!example] Преобразование объекта в `Map`
>>>```js 
>>>const obj = { name: 'John', age: 30 };
>>>const map = new Map(Object.entries(obj));
>>>console.log(map); // Map(2) { 'name' => 'John', 'age' => 30 }
>>>```
>>
>>>[!example] Использование с методами массивов
>>>```js 
>>>const obj = { apple: 10, banana: 5, orange: 15 };
>>>
>>>// Фильтрация
>>>const expensiveFruits = Object.entries(obj).filter(([_, price]) => price > 10);
>>>console.log(expensiveFruits); // [['orange', 15]]
>>>
>>>// Сортировка
>>>const sortedFruits = Object.entries(obj).sort((a, b) => b[1] - a[1]);
>>>console.log(sortedFruits); // [['orange', 15], ['apple', 10], ['banana', 5]]
>>>
>>>// Трансформация
>>>const fruitInventory = Object.entries(obj).map(([fruit, count]) => `${count} ${fruit}s`);
>>>console.log(fruitInventory); // ['10 apples', '5 bananas', '15 oranges']
>>>```
>>
>>>[!example] Деструктуризация в функциях
>>>```js 
>>>function logEntries(entries) {
>>>    entries.forEach(([key, value]) => {
>>>        console.log(`${key}: ${value}`);
>>>    });
>>>}
>>>
>>>const person = { name: 'Alice', age: 25 };
>>>logEntries(Object.entries(person));
>>>// name: Alice
>>>// age: 25
>>>```
>>
>>>[!example] Создание объекта с измененными ключами
>>>```js 
>>>const obj = { firstName: 'John', lastName: 'Doe' };
>>>const swappedObj = Object.fromEntries(
>>>    Object.entries(obj).map(([key, value]) => [value, key])
>>>);
>>>console.log(swappedObj); // { John: 'firstName', Doe: 'lastName' }
>>>```
>>
>>>[!example] Вычисление статистики:
>>>```js 
>>>const scores = { John: 85, Alice: 92, Bob: 78 };
>>>const averageScore = Object.entries(scores).reduce((sum, [_, score]) => sum + score, 0) / Object.keys(scores).length;
>>>console.log(averageScore); // 85
>>>```
>>
>>>[!example] Проверка наличия определенных пар ключ-значение:
>>>```js
>>>const requiredProps = [['name', 'John'], ['age', 30]];
>>>const obj = { name: 'John', age: 30, city: 'New York' };
>>>
>>>const hasAllRequired = requiredProps.every(([key, value]) => 
>>>   Object.entries(obj).some(([k, v]) => k === key && v === value)
>>>);
>>>console.log(hasAllRequired); // true
>>>```
>>
>>>[!example] Создание нового объекта с измененными значениями:
>>>```js
>>>const prices = { apple: 0.5, banana: 0.3, orange: 0.6 };
>>>const discountedPrices = Object.fromEntries(
>>>    Object.entries(prices).map(([fruit, price]) => [fruit, price * 0.9])
>>>);
>>>console.log(discountedPrices); // { apple: 0.45, banana: 0.27, orange: 0.54 }
>>>```
>
>>[!info]- **Object.fromEntries()**
>> - Преобразует список пар ключ-значение в объект
>> - метод, который выполняет обратное действие `Object.entries()`. Он преобразует список пар ключ-значение в объект.
>>```js
>>const entries = new Map([['foo', 'bar'],['baz', 42]]);
>>const obj = Object.fromEntries(entries);
>>console.log(obj); // { foo: "bar", baz: 42 }
>>```
>>###### Еще Примеры
>>>>[!example] Базовое использование:
>>>>```js 
>>>>const entries = [['name', 'Alice'], ['age', 30], ['city', 'New York']];
>>>>const obj = Object.fromEntries(entries);
>>>>console.log(obj);
>>>>// { name: 'Alice', age: 30, city: 'New York' }
>>>>```
>>>
>>>>[!example] Преобразование Map в объект:
>>>>```js 
>>>>const map = new Map([
>>>>    ['fruit', '🍎'],
>>>>    ['vegetable', '🥕'],
>>>>    ['meat', '🍗']
>>>>]);
>>>>const obj = Object.fromEntries(map);
>>>>console.log(obj);
>>>>// { fruit: '🍎', vegetable: '🥕', meat: '🍗' }
>>>
>>>>[!example] Фильтрация свойств объекта:
>>>>```js 
>>>>const person = { name: 'Bob', age: 25, city: 'London', country: 'UK' };
>>>>const filteredObj = Object.fromEntries(
>>>>    Object.entries(person).filter(([key]) => ['name', 'age'].includes(key))
>>>>);
>>>>console.log(filteredObj);
>>>>// { name: 'Bob', age: 25 }
>>>
>>>>[!example] Трансформация ключей или значений объекта:
>>>>```js
>>>>const prices = { apple: 0.5, banana: 0.3, orange: 0.6 };
>>>>const discountedPrices = Object.fromEntries(
>>>>    Object.entries(prices).map(([fruit, price]) => [fruit, price * 0.9])
>>>>);
>>>>console.log(discountedPrices);
>>>>// { apple: 0.45, banana: 0.27, orange: 0.54 }
>>>
>>>>[!example] Объединение объектов с преобразованием:
>>>>```js
>>>>const obj1 = { a: 1, b: 2 };
>>>>const obj2 = { c: 3, d: 4 };
>>>>const combined = Object.fromEntries([
>>>>    ...Object.entries(obj1),
>>>>    ...Object.entries(obj2).map(([key, value]) => [key.toUpperCase(), value * 2])
>>>>]);
>>>>console.log(combined);
>>>>// { a: 1, b: 2, C: 6, D: 8 }
>>>
>>>>[!example] Создание объекта из URLSearchParams:
>>>>```js
>>>>const searchParams = new URLSearchParams('key1=value1&key2=value2');
>>>>const obj = Object.fromEntries(searchParams);
>>>>console.log(obj);
>>>>// { key1: 'value1', key2: 'value2' }
>>>
>>>>[!example] Инвертирование объекта (обмен ключей и значений):
>>>>```js
>>>>const original = { a: 1, b: 2, c: 3 };
>>>>const inverted = Object.fromEntries(
>>>>    Object.entries(original).map(([key, value]) => [value, key])
>>>>);
>>>>console.log(inverted);
>>>>// { '1': 'a', '2': 'b', '3': 'c' }
>>>
>>>>[!example] Создание объекта с вычисляемыми свойствами:
>>>>```js
>>>>const keys = ['name', 'age', 'city'];
>>>>const values = ['Eve', 28, 'Paris'];
>>>>const obj = Object.fromEntries(keys.map((key, index) => [key, values[index]]));
>>>>console.log(obj);
>>>>// { name: 'Eve', age: 28, city: 'Paris' }
>>>>```
>
>>[!info]- **Object.keys()**
>>Возвращает массив строковых элементов, соответствующих именам перечисляемых свойств
>>```js
>>const object1 = { a: 'somestring', b: 42, c: false };
>>console.log(Object.keys(object1)); // ["a", "b", "c"]
>>```
>
>>[!info]- **Object.values()**
>>Возвращает массив значений перечисляемых свойств объекта
>>```js
>>const object1 = { a: 'somestring', b: 42, c: false };
>>console.log(Object.values(object1)); // ["somestring", 42, false]
>>```
>
>>[!info]- **Object.freeze()**
>>Замораживает объект: другой код не сможет удалить или изменить его свойства
>>```js
>>const obj = { prop: 42 };
>>Object.freeze(obj);
>>obj.prop = 33; // Throws an error in strict mode
>>console.log(obj.prop); // 42
>>```
>
>>[!info]- **Object.getOwnPropertyDescriptor()**
>>Возвращает дескриптор свойства для собственного свойства объекта
>>```js
>>const object1 = { property1: 42 };
>>const descriptor1 = Object.getOwnPropertyDescriptor(object1, 'property1');
>>console.log(descriptor1.configurable); // true
>>console.log(descriptor1.value); // 42
>>```
>
>>[!info]- **Object.getOwnPropertyDescriptors()**
>>Возвращает все собственные дескрипторы свойств данного объекта
>>```js
>>const object1 = { property1: 42 };
>>const descriptors1 = Object.getOwnPropertyDescriptors(object1);
>>console.log(descriptors1.property1.writable); // true
>>console.log(descriptors1.property1.value); // 42
>>```
>
>>[!info]- **Object.getOwnPropertyNames()**
>>Возвращает массив со всеми свойствами (независимо от того, перечисляемые они или нет)
>>```js
>>const object1 = { a: 1, b: 2, c: 3 };
>>console.log(Object.getOwnPropertyNames(object1)); // ["a", "b", "c"]
>>```
>
>>[!info]- **Object.getOwnPropertySymbols()**
>>Возвращает массив всех символьных свойств, найденных непосредственно на объекте
>>```js
>>const obj = {};
>>const a = Symbol('a');
>>const b = Symbol.for('b');
>>obj[a] = 'localSymbol';
>>obj[b] = 'globalSymbol';
>>const objectSymbols = Object.getOwnPropertySymbols(obj);
>>console.log(objectSymbols.length); // 2
>>```
>
>>[!info]- **Object.getPrototypeOf()**
>>Возвращает прототип указанного объекта
>>```js
>>const prototype1 = {};
>>const object1 = Object.create(prototype1);
>>console.log(Object.getPrototypeOf(object1) === prototype1); // true
>>```
>
>>[!info]- **Object.is()**
>>Определяет, являются ли два значения одним и тем же значением
>>```js
>>console.log(Object.is('foo', 'foo')); // true
>>console.log(Object.is(window, window)); // true
>>console.log(Object.is('foo', 'bar')); // false
>>console.log(Object.is([], [])); // false
>>```
>
>>[!info]- **Object.isExtensible()**
>>Определяет, является ли объект расширяемым
>>```js
>>const object1 = {};
>>console.log(Object.isExtensible(object1)); // true
>>Object.preventExtensions(object1);
>>console.log(Object.isExtensible(object1)); // false
>>```
>
>>[!info]- **Object.isFrozen()**
>>Определяет, был ли объект заморожен
>>```js
>>const object1 = { property1: 42 };
>>console.log(Object.isFrozen(object1)); // false
>>Object.freeze(object1);
>>console.log(Object.isFrozen(object1)); // true
>>```
>
>>[!info]- **Object.isSealed()**
>>Определяет, является ли объект запечатанным
>>```js
>>const object1 = { property1: 42 };
>>console.log(Object.isSealed(object1)); // false
>>Object.seal(object1);
>>console.log(Object.isSealed(object1)); // true
>>```
>
>>[!info]- **Object.preventExtensions()**
>>Предотвращает добавление новых свойств к объекту
>>```js
>>const object1 = {};
>>Object.preventExtensions(object1);
>>try {
>>    Object.defineProperty(object1, 'property1', { value: 42 });
>>} catch (e) {
>>    console.log(e); // TypeError: Cannot define property property1, object is not extensible
>>}
>>```
>
>>[!info]- **Object.seal()**
>>Запечатывает объект, предотвращая добавление новых свойств и делая все существующие свойства неконфигурируемыми
>>```js
>>const object1 = { property1: 42 };
>>Object.seal(object1);
>>object1.property1 = 33;
>>console.log(object1.property1); // 33
>>delete object1.property1; // cannot delete when sealed
>>console.log(object1.property1); // 33
>>```
>
>>[!info]- **Object.setPrototypeOf()**
>>Устанавливает прототип (т.е., внутреннее свойство [[Prototype]]) указанного объекта в другой объект или null
>>```js
>>const obj = { a: 1 };
>>const parent = { b: 2 };
>>Object.setPrototypeOf(obj, parent);
>>console.log(obj.b); // 2
>>```
>
>>[!info]- **Object.defineProperty()**
>>Определяет новое или изменяет существующее свойство непосредственно на объекте
>>```js
>>const object1 = {};
>>Object.defineProperty(object1, 'property1', {
>>    value: 42,
>>    writable: false
>>});
>>object1.property1 = 77; // throws an error in strict mode
>>console.log(object1.property1); // 42
>>```
>
>>[!info]- **Object.defineProperties()**
>>Определяет новые или изменяет существующие свойства непосредственно на объекте, возвращая этот объект
>>```js
>>const object1 = {};
>>Object.defineProperties(object1, {
>>    property1: { value: 42, writable: true },
>>    property2: {}
>>});
>>console.log(object1.property1); // 42
>>```

# операторы-объектов
>[!help] **Операторы и ключевые слова для работы с объектами**
>>[!info] `delete` - удаляет свойство из объекта
>>```js
>>const person = { name: 'Alice', age: 30, job: 'developer' };
>>console.log(person); // { name: 'Alice', age: 30, job: 'developer' }
>>
>>delete person.age;
>>console.log(person); // { name: 'Alice', job: 'developer' }
>>
>>// Попытка удалить несуществующее свойство
>>console.log(delete person.salary); // true (но ничего не меняется)
>>
>>// Удаление с использованием квадратных скобок
>>delete person['job'];
>>console.log(person); // { name: 'Alice' }
>>```
>
>>[!info] `in` - проверяет наличие свойства в объекте (включая прототип)
>>```js
>>const car = { make: 'Toyota', model: 'Corolla' };
>>console.log('make' in car); // true
>>console.log('year' in car); // false
>>
>>// Проверка свойства из прототипа
>>console.log('toString' in car); // true
>>
>>// Использование с переменной
>>const prop = 'model';
>>console.log(prop in car); // true
>>```
>
>>[!info] `instanceof` - проверяет, принадлежит ли объект к определенному классу
>>```js
>>class Animal {}
>>class Dog extends Animal {}
>>
>>const myDog = new Dog();
>>console.log(myDog instanceof Dog); // true
>>console.log(myDog instanceof Animal); // true
>>console.log(myDog instanceof Object); // true
>>
>>const arr = [1, 2, 3];
>>console.log(arr instanceof Array); // true
>>console.log(arr instanceof Object); // true
>>```
>
>>[!info] `new` - создает экземпляр объекта
>>```js
>>function Person(name) {
>>    this.name = name;
>>}
>>
>>const alice = new Person('Alice');
>>console.log(alice.name); // 'Alice'
>>
>>// Использование с встроенными объектами
>>const currentDate = new Date();
>>console.log(currentDate);
>>
>>const regex = new RegExp('\\d+');
>>console.log(regex.test('123')); // true
>>```
>
>>[!info] `this` - ссылается на текущий контекст выполнения
>>```js
>>const person = {
>>    name: 'Bob',
>>    greet: function() {
>>        console.log(`Hello, my name is ${this.name}`);
>>    },
>>    friends: ['Alice', 'Charlie'],
>>    introduceFriends: function() {
>>        this.friends.forEach(function(friend) {
>>            console.log(`${this.name}'s friend: ${friend}`);
>>        }.bind(this));
>>    }
>>};
>>
>>person.greet(); // "Hello, my name is Bob"
>>person.introduceFriends();
>>// "Bob's friend: Alice"
>>// "Bob's friend: Charlie"
>>```
>
>>[!info] `void` - вычисляет выражение и возвращает undefined
>>```js
>>console.log(void 0); // undefined
>>
>>// Использование в ссылках
>>const link = document.createElement('a');
>>link.href = 'javascript:void(0)';
>>link.onclick = function() { console.log('Clicked!'); return false; };
>>
>>// Немедленное выполнение функции без сохранения результата
>>void function() {
>>    console.log('This function is executed immediately');
>>}();
>>```

# Map Set WeakMap WeakSet
>[!help]
>Эти структуры данных предоставляют эффективные способы хранения и управления коллекциями данных в JS. 
>   - `Map` используется для хранения пар ключ-значение.
>   - `Set` для хранения уникальных значений. 
>   - `WeakMap` и `WeakSet` предоставляют специальные версии с `weak references`, что полезно для определенных сценариев управления памятью.
>>   ###### Преимущества перед обычными `Map` и `Set`:
>>    1.  ***Автоматическая очистка памяти***: объекты-ключи могут быть собраны сборщиком мусора, если на них нет других ссылок.
>>    2.  ***Отсутствие влияния на управление памятью***: использование `WeakMap/WeakSet` не препятствует сборке мусора объектов-ключей.
>>    3.  ***Безопасность***: невозможно получить список всех ключей/значений, что полезно для приватных данных.
>
>>[!example]- **Map**
>>Коллекция пар ключ-значение, где ключи могут быть любого типа
>> ###### Методы `Map`
>>>  - `map.set()`   - Добавление элементов
>>>  - `map.get()`   - Получение значений
>>>  - `map.size`    - Получение размера `Map`
>>>  - `map.has()`   - Проверка наличия ключа
>>>  - `map.delete()`- Удаление элемента
>>>  - `map.clear()` - Очистка `Map`
>>```js
>>const map = new Map();
>>
>>// Добавление элементов
>>map.set('name', 'Alice');
>>map.set(42, 'answer');
>>map.set({}, 'object');
>>
>>// Получение значений
>>console.log(map.get('name')); // 'Alice'
>>console.log(map.size); // 3
>>
>>// Проверка наличия ключа
>>console.log(map.has(42)); // true
>>
>>// Удаление элемента
>>map.delete(42);
>>
>>// Перебор элементов
>>for (let [key, value] of map) {
>>    console.log(`${key} = ${value}`);
>>}
>>
>>// Очистка Map
>>map.clear();
>>```
>
>>[!example]- **Set**
>>Коллекция уникальных значений любого типа
>> ###### Методы `Set`
>>>  - `set.add()`   - Добавление элементов
>>>  - `set.size`  - Получение размера `Map`
>>>  - `set.has()`   - Проверка наличия ключа
>>>  - `set.delete()`- Удаление элемента
>>>  - `set.clear()` - Очистка `Map`
>>>
>>>В `Set` нет необходимости в методе `get()`, потому что `Set` хранит только уникальные значения, а не пары ключ-значение. Если вам нужно "получить" значение из `Set`, вы просто проверяете его наличие с помощью метода `has()`.
>>```js
>>const set = new Set();
>>
>>// Добавление элементов
>>set.add(1);
>>set.add('two');
>>set.add({three: 3});
>>
>>// Попытка добавить дубликат
>>set.add(1);
>>
>>console.log(set.size); // 3
>>
>>// Проверка наличия элемента
>>console.log(set.has('two')); // true
>>
>>// Удаление элемента
>>set.delete('two');
>>
>>// Перебор элементов
>>for (let item of set) {
>>    console.log(item);
>>}
>>
>>// Преобразование Set в массив
>>const array = [...set];
>>
>>// Очистка Set
>>set.clear();
>>```
>
>>[!example]- **WeakMap и WeakSet**
>>Специальные версии `Map` и `Set` с "слабыми" ссылками на объекты
>> При переприсванивание `WeakMap` и `WeakSet` на `null` то они теперь будут доступены для сборки мусора.
>>
>> ###### `WeakMap` и `WeakSet` имеют меньше методов, чем их "сильные" аналоги: 
>>> ***WeakMap***:
>>> - `set(key, value)`
>>> - `get(key)`
>>> - `has(key)`
>>> - `delete(key)`
>>>
>>> ***WeakSet***:
>>> - `add(value)`
>>> - `has(value)`
>>> - `delete(value)`
>>>
>>> ***Важные отличия***:
>>> - У них нет методов `clear()` и свойства `size`.
>>> - Они не являются перебираемыми (нет методов `keys()`, `values()`, `entries()`, `forEach()`).
>>```js
>>// WeakMap
>>const weakMap = new WeakMap();
>>let obj = {};
>>
>>weakMap.set(obj, 'associated data');
>>console.log(weakMap.get(obj)); // 'associated data'
>>
>>obj = null; // obj теперь доступен для сборки мусора
>>
>>// WeakSet
>>const weakSet = new WeakSet();
>>let obj2 = {};
>>
>>weakSet.add(obj2);
>>console.log(weakSet.has(obj2)); // true
>>
>>obj2 = null; // obj2 теперь доступен для сборки мусора
>>```

# клонирование-объектов
>[!help] 
>>[!quote]
>>Способы делятся на два типа клонирования:
>> 1. **Поверхностное `(Shallow Clone)`** 
>>      - Поверхностное клонирование создает новый объект, но копирует только ссылки на вложенные объекты. Это значит, что изменения в вложенных объектах будут отражаться и в оригинале, и в клоне.
>> 2. **Глубокое `(Deep Clone)`**
>>      - Глубокое клонирование создает полностью независимую копию объекта, включая все вложенные объекты.
>
>>[!example] Поверхностное клонирование (Shallow Clone)
>>Создает новый объект, копируя только ссылки на вложенные объекты
>>```js
>>// Spread оператор
>>const original = { a: 1, b: { c: 2 } };
>>const shallowClone1 = { ...original };
>>
>>// Object.assign()
>>const shallowClone2 = Object.assign({}, original);
>>
>>// Метод slice() для массивов
>>const originalArray = [1, 2, 3];
>>const shallowCloneArray = originalArray.slice();
>>```
>
>>[!example] Глубокое клонирование (Deep Clone)
>>Создает полностью независимую копию объекта, включая все вложенные объекты
>>```js
>>// JSON.parse() и JSON.stringify()
>>const deepClone1 = JSON.parse(JSON.stringify(original));
>>
>>// structuredClone() (современный метод)
>>const deepClone2 = structuredClone(original);
>>```
>
>>[!info] **Особенности и ограничения**
>>- `JSON.parse(JSON.stringify())`: не работает с функциями, `undefined`, `Symbol`, `BigInt` теряет специальные типы данных
>>- `structuredClone()`: не поддерживает клонирование функций и прототипов объектов
>>- Производительность: для небольших объектов `JSON` метод может быть эффективен, для больших - лучше использовать специализированные библиотеки
>>- Библиотеки: ***lodash*** `_.cloneDeep()`, ***Ramda*** `R.clone()`
>>- Особые случаи: `DOM-узлы` и экземпляры классов могут требовать специфической логики клонирования


# event-loop

# for-in/for-of
