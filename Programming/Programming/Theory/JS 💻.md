# JS
> [!help] 
> 
>JavaScript - это:
>1. **Высокоуровневый язык программирования  **  
>    - Абстрагирован от машинного кода, более близок к человеческому языку.
>      > [!info]-
>      > JavaScript можно использовать для иллюстрации принципа ***абстракции*** в  ([[ООП]]). Абстракция позволяет нам работать с объектами через их интерфейсы, скрывая внутреннюю реализацию и сложность.
>    - Обеспечивает автоматическое управление памятью (сборка мусора).
>2. **Динамически типизируемый **   
>    - Типы переменных определяются во время выполнения.
>    - Переменная может хранить значения разных типов в разное время.
>3. **Слабо типизированный**    
>    - Допускает неявное приведение типов.
>4. **Интерпретируемый**    
>    - Код выполняется построчно без предварительной компиляции.
>   > [!info]- 
>   >###### Построчное выполнение:
>   >   - Интерпретатор проходит по коду один раз, выполняя каждую инструкцию по порядку.
>   >###### Процесс выполнения:
>   >   - Код загружается и анализируется (парсится).
>   >   - Затем он выполняется сверху вниз, инструкция за инструкцией.
>   >   - После выполнения всех инструкций программа завершается, если нет бесконечных циклов или событийных слушателей.
>   >###### Контекст веб-страницы:
>   >   - В браузере JavaScript не "крутится" постоянно после загрузки страницы.
>   >   - Вместо этого, после выполнения начального кода, движок JavaScript ожидает событий (клики, таймеры и т.д.).
>   >###### Событийный цикл ([Event Loop](#event-loop)):
>   >   - JavaScript использует событийную модель.
>   >   - После выполнения начального кода, движок входит в состояние ожидания событий.
>   >   - Когда происходит событие, соответствующий обработчик выполняется.
>   >###### Память и выполнение:
>   >   - Интерпретатор не "запоминает" код в том смысле, в котором это делает компилятор.
>   >   - Однако, современные движки JavaScript (как V8) могут кэшировать результаты парсинга и даже компилировать часто используемый код (JIT-компиляция).
>   >###### Глобальный контекст:
>   >   - Глобальные переменные и функции остаются в памяти, пока страница открыта.
>   >   - Это позволяет обращаться к ним из обработчиков событий в любое время.
>    - Современные движки JS используют JIT-компиляцию для оптимизации производительности.
>   > [!info]- 
>   >JIT (Just-In-Time) подход позволяет JavaScript в Chrome быстро начинать выполнение (благодаря интерпретации) и достигать высокой производительности для критических участков кода (благодаря оптимизирующей компиляции).
>   > **JIT (Just-In-Time)** компиляция в V8 -  включает несколько уровней оптимизации. Вот как это работает в общих чертах:
>   >1. ***Интерпретация***:   
>   >    - Сначала весь код интерпретируется построчно интерпретатором Ignition.
>   >2. ***Профилирование***:    
>   >    - Во время выполнения V8 собирает информацию о том, как часто выполняются различные части кода и какие типы данных используются.
>   >3. ***Базовая JIT-компиляция***:    
>   >    - Часто выполняемые функции компилируются в машинный код компилятором TurboFan.
>   >    - Этот код быстрее интерпретируемого, но еще не полностью оптимизирован.
>   >4. ***Оптимизирующая компиляция***:    
>   >    - Для "горячего" кода (очень часто выполняемого) применяется агрессивная оптимизация.
>   >   - Здесь используется собранная информация о типах и поведении кода для создания высокооптимизированного машинного кода.
>   >5. ***Деоптимизация***:   
>   >    - Если предположения, сделанные при оптимизации, оказываются неверными (например, тип переменной изменился), код "деоптимизируется" и возвращается к менее оптимизированной версии или к интерпретации.
>   >6. ***Адаптивная оптимизация***:    
>   >    - V8 продолжает мониторить выполнение и может повторно оптимизировать код, если паттерны использования изменяются.
>   > ###### Ключевые моменты:
>   >>- Не весь код компилируется. Редко используемый код может остаться интерпретируемым.
>   >>- Компиляция происходит параллельно с выполнением программы.
>   >>- Уровень оптимизации зависит от частоты использования кода и стабильности типов.
>   >>- V8 балансирует между скоростью запуска (интерпретация) и скоростью выполнения (компиляция).
>  
>5. **Встраиваемый**    
>    - Может быть встроен в веб-браузеры и другие хост-среды (например, Node.js).
>    - Не имеет собственного ввода/вывода, полагается на хост-среду для этих функций.
>6. **Мультипарадигменный**   
>    - Поддерживает процедурное, объектно-ориентированное и функциональное программирование.
>      > [!info]- 
>      > ###### Основные парадигмы программирования:
>      >>1. ***Императивное программирование***
>      >>    - Процедурное программирование
>      >>    - Объектно-ориентированное программирование ([[ООП]])
>      >>2. ***Декларативное программирование ***   
>      >>    - Функциональное программирование
>      >>    - Логическое программирование
>      >>3. ***Структурное программирование***    
>      >>4. ***Событийно-ориентированное программирование***  
>      >>5. ***Аспектно-ориентированное программирование***    
>      >>6. ***Прототипно-ориентированное программирование***    
>      >>7. ***Компонентно-ориентированное программирование***    
>      >>8. ***Параллельное программирование***
>      >>9. ***Реактивное программирование***   
>      > ###### Парадигмы, которые хорошо подходят для JavaScript и широко в нем используются:
>      >>1. ***Процедурное программирование***:  
>      >>    JavaScript позволяет писать последовательные инструкции и организовывать код в функции.   
>      >>    ```js
>      >>    function calculateArea(width, height) {
>      >>        return width * height;
>      >>    }
>      >>      
>      >> 2. ***Объектно-ориентированное программирование***:  
>      >>    JavaScript поддерживает ООП как через прототипы, так и через классы (с ES6).  
>      >>    ```js
>      >>    class Rectangle {
>      >>        constructor(width, height) {
>      >>           this.width = width;
>      >>            this.height = height;
>      >>        }
>      >>        
>      >>        getArea() {
>      >>            return this.width * this.height;
>      >>        }
>      >>    }
>      >>    ```   
>      >>3. ***Функциональное программирование***:  
>      >>    JavaScript поддерживает функции первого класса, замыкания и другие функциональные концепции.    
>      >>    ```js
>      >>   const multiply = (a, b) => a * b;
>      >>    const numbers = [1, 2, 3, 4, 5];
>      >>    const doubled = numbers.map(n => n * 2);
>      >>    ```    
>      >>4. ***Прототипно-ориентированное программирование***:  
>      >>    Это основной механизм наследования в JavaScript.   
>      >>    ```js
>      >>    function Animal(name) {
>      >>        this.name = name;
>      >>    }
>      >>    Animal.prototype.speak = function() {
>      >>        console.log(this.name + ' makes a noise.');
>      >>    };
>      >>    ```
>      >>   
>      >>5. ***Событийно-ориентированное программирование***:  
>      >>    Широко используется в JavaScript, особенно в веб-разработке.
>      >>    ```
>      >>    document.getElementById('myButton').addEventListener('click', function() {
>      >>        console.log('Button clicked!');
>      >>    });
>      >>    ```  
>      >>6. ***Компонентно-ориентированное программирование***:  
>      >>    Популярно в современных фреймворках, таких как React, Vue, Angular.
>      >>    ```ts
>      >>   // Пример React-компонента
>      >>    function Welcome(props) {
>      >>        return <h1>Hello, {props.name}</h1>;
>      >>    }
>      >>    ```   
>      >>7. ***Реактивное программирование***:  
>      >>    Поддерживается через библиотеки, такие как RxJS.
>      >>    ```js
>      >>    // Пример с использованием RxJS
>      >>    import { fromEvent } from 'rxjs';
>      >>    import { map } from 'rxjs/operators';
>      >>    
>      >>    const clicks = fromEvent(document, 'click');
>      >>    const positions = clicks.pipe(map(ev => ev.clientX));
>      >>    positions.subscribe(x => console.log(x));
>      >>    ```   
>      >>8. ***Асинхронное программирование***:  
>      >>    JavaScript отлично поддерживает асинхронное программирование через callbacks, promises и async/await.
>      >>    ```js
>      >>    async function fetchData() {
>      >>       try {
>      >>            const response = await fetch('https://api.example.com/data');
>      >>            const data = await response.json();
>      >>            console.log(data);
>      >>        } catch (error) {
>      >>            console.error('Fetching error:', error);
>      >>        }
>      >>    }
>      >>    ```
>      >> ###### Заключение:  
>      >>>JavaScript действительно является мультипарадигменным языком, поддерживающим множество различных подходов к программированию. Это дает разработчикам большую гибкость в выборе наиболее подходящего стиля для конкретной задачи или проекта. Наиболее часто в JavaScript используются процедурное, объектно-ориентированное и функциональное программирование, но язык также хорошо поддерживает событийно-ориентированное, компонентно-ориентированное и реактивное программирование. Выбор парадигмы часто зависит от конкретных требований проекта, личных предпочтений разработчика и используемых фреймворков или библиотек.
>      > 
>      > 
>  
>7. **Прототипно-ориентированный**    
>    - Использует прототипы для наследования, в отличие от классического [[ООП]].
>8. **Однопоточный с асинхронностью**    
>    - Имеет однопоточную модель выполнения.
>    - Поддерживает асинхронное программирование через callbacks, Promises и async/await.
>9. **Кроссплатформенный**   
>    - Работает на различных платформах и устройствах.
>10. **С поддержкой функций первого класса**    
>       - Функции могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
>       - 

# типы-данных
> [!help] 
> В JavaScript есть **8** основных типов данных:
>1. **Number** (число)
>    - Включает целые числа и числа с плавающей точкой.
>    - Пример: 42, 3.14
>2. **String** (строка)    
>    - Текстовые данные.
>    - Пример: "Hello", 'World'
>3. **Boolean** (логический тип)    
>    - true или false
>4. **Undefined**    
>    - Представляет переменную, которой не присвоено значение.
>    - ***typeof undefined*** возвращает ***"undefined"***
>5. **Null**   
>    - Представляет намеренное отсутствие какого-либо объектного значения.
>    - В отличие от undefined, null всегда присваивается намеренно.
>    - null используется для явного указания на отсутствие значения или "пустоту".
>    - ***typeof null*** возвращает ***"object"***
>6. **Object** (объект)    
>    - Коллекция свойств.
>    - Пример: {name: "John", age: 30}
>7. **Symbol** (символ)    
>    - Уникальный идентификатор.
>    - Введен в ECMAScript 6.
>8. **BigInt**    
>    - Для работы с целыми числами произвольной длины.
>    - Введен в ECMAScript 2020.
>    - Пример: 1234567890123456789012345678901234567890n
> ###### Важные замечания:
>>1. **Массивы и функции**:    
>>    - Технически, массивы (Array) и функции (Function) являются подтипами Object. Но их часто рассматривают как отдельные типы из-за их особого поведения.
>>2. **Примитивные типы**:    
>>    - Number, String, Boolean, Undefined, Null, Symbol и BigInt считаются примитивными типами.
>>    - Object - это непримитивный тип.
>>3. **Специальные объекты**:    
>>    - Date, RegExp, Error и другие встроенные объекты часто упоминаются при обсуждении типов данных, но они являются подтипами Object.
>>4. **typeof оператор**:    
>>    - Оператор typeof может возвращать следующие строки: "number", "string", "boolean", "undefined", "object", "function", "symbol", "bigint".
>>    - Обратите внимание, что typeof null возвращает "object", что считается исторической ошибкой в языке.
>  

# var-let-const
> [!help] 
> 1. **var**:   
>    - [Функциональная область видимости](#области-видимости) 
>         - если объявлена вне функции, то имеет [глобальную область видимости](#области-видимости).
>    - [Поднятие (hoisting)](#поднятие(hosting)) `var` поднимается и инициализируется значением undefined
>    - Можно переопределять
>    - Существует с начала JavaScript
>2. **let**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (точнее, есть "временная мертвая зона"), поднимаются, но не инициализируются
>    - Можно переопределять
>    - Введено в ES6 (2015)
>3. **const**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (как и `let`), поднимаются, но не инициализируются
>    - Нельзя переопределять (но можно изменять содержимое объектов)
>    - Введено в ES6 (2015)
>  
>  > [!example] 
>   >> Если `var` объявлена вне функции, она становится глобальной переменной и свойством глобального объекта (`window` в браузере).
>   >> ```js
>   >>var globalVar = "I'm global";
>   >>console.log(window.globalVar); // "I'm global" (в браузере)
>   >>console.log(globalVar);        // "I'm global" (в браузере)
>   >>```
>   >>Переменная `globalVar`, объявленная с помощью `var`, становится как глобальной переменной, так и свойством объекта `window`. Поэтому мы можем обращаться к ней обоими способами.
>   > ---
>   >>Если `let` или `const` объявлены вне любого блока (в глобальной области), они становятся глобальными переменными, но не становятся свойствами глобального объекта.
>   >> ```js
>   >>let globalLet = "I'm global";
>   >>const globalConst = "I'm also global";
>   >>console.log(window.globalLet);    // undefined (в браузере)
>   >>console.log(window.globalConst);  // undefined (в браузере)
>   >>console.log(globalLet);    // "I'm global" (в браузере)
>   >>console.log(globalConst);  // "I'm also global" (в браузере)
>   >>```
>   >> Переменные `globalLet` и `globalConst`, хотя и являются глобальными (доступны во всем скрипте), не становятся свойствами объекта `window`. Поэтому мы можем обращаться к ним напрямую, но не через window.
>
>  > [!info] 
>> Теоретические причины, по которым var может быть быстрее:
>>1. Отсутствие проверки временной мертвой зоны (TDZ):    
>>    - let и const имеют временную мертвую зону, var - нет.
>>    - Движок JS должен проверять, не находится ли переменная в TDZ при каждом обращении к ней.
>>2. Более простая область видимости:    
>>    - var имеет функциональную область видимости.
>>    - let и const имеют блочную область видимости, что может требовать более сложной логики для отслеживания.
>>3. Поднятие (hoisting):   
>>    - var поднимается и инициализируется значением undefined.
>>    - let и const поднимаются, но не инициализируются, что требует дополнительных проверок. 
>>      
# области-видимости

> [!help] 
>> [!quote] 
>>  - **Глобальная область видимости** - Это самый внешний уровень области видимости. Переменные, объявленные здесь, доступны во всем скрипте.
>
>> [!quote] 
>>  - **Функциональная область видимости** -  Переменные, объявленные внутри функции, доступны только внутри этой функции.
>
>> [!quote] 
>>  - **Блочная область видимости** - Переменные доступны только внутри блока, где они объявлены.
>  
# поднятие(hosting)
> [!help] 
> > [!quote] 
> **Hoisting** (поднятие) — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их [области видимости](#области-видимости) во время выполнения кода. Это позволяет использовать переменные и функции до их фактического объявления в коде.  
> ###### Hoisting переменных
>> 1. **Переменные, объявленные с помощью `var`**:  
>>    - Объявление переменной поднимается, но инициализация остаётся на месте.         
>>        ```javascript
>>        console.log(x); // undefined
>>        var x = 5;
>>        console.log(x); // 5
>>        ```     
>2. **Переменные, объявленные с помощью `let` и `const`**:
>>   
>>    - Объявление переменной поднимается, но она не инициализируется. Доступ к переменной до её объявления вызывает ошибку.
>>    - Пример:      
>>        ```javascript
>>        console.log(y); // ReferenceError: Cannot access 'y' before initialization
>>        let y = 10;
>>        ```
>> ###### Пример с глобальной и локальной переменными
>>>```js 
>>>function scope() {
>>>  a = 42;
>>>  var b = 43;
>>>}
>>>scope();
>>>console.log(a); // 42
>>>console.log(b); // ReferenceError: b is not defined
>>>```
>> Так как переменная `a` не была объявлена, то JavaScript сам решил, где объявлять переменную, и «поднял» объявление наверх. Получился вот такой код:
>>>```js 
>>>var a
>>>function scope() {
>>>  a = 42
>>>  var b = 43
>>>}
>>>scope()
>>>console.log(a)
>>>// 42
> >
> ###### Hoisting функций
> > 1. **Функции, объявленные с помощью `function`**:
> >    - Объявление и определение функции поднимаются, что позволяет вызывать функцию до её объявления.
> >        ```javascript
> >        catName("Тигр"); // "Мою кошку зовут Тигр"        
> >        function catName(name) {
> >          console.log("Мою кошку зовут " + name);
> >        }
> >        ```       
> >2. **Функции, присвоенные переменной**:    
> >    - Объявление переменной поднимается, но инициализация функцией не поднимается. Попытка вызвать функцию до её инициализации вызывает ошибку.
> >        ```javascript
> >        console.log(catName); // undefined
> >        catName("Тигр"); // TypeError: catName is not a function        
> >        var catName = function(name) {
> >          console.log("Мою кошку зовут " + name);
> >        };
>> 
>
> > [!summary]
>***Hoisting*** в JavaScript поднимает объявления переменных и функций в начало их области видимости. Это позволяет использовать их до фактического объявления в коде, но важно помнить, что инициализация переменных не поднимается. Переменные, объявленные с помощью `let` и `const`, ведут себя иначе и не доступны до их инициализации.      
# объявления-функций
> [!help] 
>###### Function Declaration (Объявление функции)
>>```js
>>function greet(name) {
>>    console.log(`Hello, ${name}!`);
>>}
>>greet("Alice"); // Выведет: Hello, Alice! 
>>```
>>**Особенности**:
>>- Поднимается [(hoisting)](#поднятие(hosting)) в начало своей области видимости.
>>- Можно вызвать до объявления в коде.
>>- Имеет свой собственный `this`.
>>
>>**Контекст**(`this`):
>>***Function Declaration*** создает свой собственный контекст выполнения. Значение `this` внутри такой функции зависит от того, как она вызывается.
>>```js
>>const obj = {
>>    name: "John",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm John
>>const hi = obj.sayHi;
>>hi(); // Выведет: Hi, I'm undefined (в нестрогом режиме) или выбросит ошибку (в строгом режиме)
>>```
> ###### Function Expression (Функциональное выражение)
>>```js
>>const greet = function(name) {
>>    console.log(`Hello, ${name}!`);
>>};
>>greet("Bob"); // Выведет: Hello, Bob!
>>```
>>**Особенности**:
>> - Не поднимается (no hoisting).
>> - Нельзя вызвать до объявления в коде.
>> - Может быть анонимной или именованной.
>> - Имеет свой собственный `this`.
>>
>>**Контекст**:
>>***Function Expression***, как и ***Function Declaration***, создает свой собственный контекст выполнения.
>>```js
>>const obj = {
>>    name: "Sarah",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm Sarah
> ###### Arrow Function (Стрелочная функция)
>>```js
>>const greet = (name) => {
>>    console.log(`Hello, ${name}!`);
>>};
>>
>>greet("Charlie"); // Выведет: Hello, Charlie!
>>```
>>**Особенности**:
>> - Более краткий синтаксис.
>> - Не имеет собственного `this`.
>> - Не может быть использована как конструктор.
>> - Не имеет собственного `arguments`.
>>> [!customname]- Что еще за `arguments`
>>> В JS, традиционные функции (***Function Declaration*** и ***Function Expression***) имеют доступ к специальному объекту `arguments`. Этот объект содержит все аргументы, переданные функции, даже если они не были объявлены в списке параметров.
>>>```js
>>>function regularFunction() {
>>>   console.log(arguments);
>>>   console.log(arguments.length);
>>>   console.log(arguments[0]);
>>>}
>>>regularFunction(1, 'a', true);
>>>// Выведет:
>>>// [1, 'a', true]
>>>// 3
>>>// 1
>>>```
>>> Однако стрелочные функции не имеют собственного `arguments`. Если вы попытаетесь получить доступ к arguments внутри стрелочной функции, вы получите `arguments` из внешней (не стрелочной) функции, если такая есть, или ошибку, если внешней функции нет.
>>>
>>>---
>>>
>>>**Пример со стрелочной функцией:**
>>>```js
>>>const arrowFunction = () => {
>>>    console.log(arguments);
>>>};
>>>arrowFunction(1, 'a', true);
>>>// Выбросит ошибку: ReferenceError: arguments is not defined
>>>```
>>>**Пример вложенной стрелочной функции:**
>>>```js
>>>function outerFunction() {
>>>    const arrowFunction = () => {
>>>        console.log(arguments);
>>>    };
>>>    arrowFunction(1, 'a', true);
>>>}
>>>outerFunction(4, 5, 6);
>>>// Выведет: [4, 5, 6]
>>>// Заметьте, что это аргументы внешней функции, а не стрелочной
>>
>> **Контекст**:
>>Arrow Function не создает свой собственный контекст выполнения. Вместо этого она захватывает `this` из окружающего лексического контекста.
>>```js
>>const obj = {
>>    name: "Mike",
>>    sayHi: () => {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm undefined
>>```
>
>**Пример, демонстрирующий разницу в контексте**:
>>> [!example] 
>>>```js
>>>  const obj = {
>>>    name: "Alice",
>>>    sayHiRegular: function() {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    },
>>>    sayHiArrow: () => {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    }
>>>};
>>>obj.sayHiRegular(); // Выведет: Hi, I'm Alice
>>>obj.sayHiArrow();   // Выведет: Hi, I'm undefined
>>>```
>>> **Использование в callback'ах**
>>>```js
>>>const objWithCallback = {
>>>    name: "Bob",
>>>    friends: ["Alice", "Charlie"],
>>>    greetFriendsRegular: function() {
>>>        this.friends.forEach(function(friend) {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь не ссылается на objWithCallback
>>>        });
>>>    },
>>>    greetFriendsArrow: function() {
>>>        this.friends.forEach((friend) => {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь ссылается на objWithCallback
>>>       });
>>>    }
>>>};
>>>objWithCallback.greetFriendsRegular(); // Выведет: undefined greets Alice, undefined greets Charlie
>>>objWithCallback.greetFriendsArrow();   // Выведет: Bob greets Alice, Bob greets Charlie
>>>```
>>>
>>>**Основные различия**:
>>> - ***Function Declaration*** поднимается, ***Function Expression*** и ***Arrow Function*** - нет.
>>> - ***Arrow Function*** не имеет собственного `this`, в отличие от других типов функций.
>>> - ***Arrow Functio***n имеет более краткий синтаксис.
>>> - ***Function Declaration*** и ***Function Expression*** могут быть использованы как конструкторы, ***Arrow Function*** - нет.
>
# замыкание
> [!help] 
>>[!quote]
>> **Замыкание**(Closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Другими словами, это способность функции запоминать и получать доступ к переменным из внешней по отношению к ней области видимости, даже когда функция выполняется вне этой области видимости.
>
> ###### Ключевые аспекты замыканий:
>> 1. **Функция внутри функции**:
>>      - Замыкание обычно создается, когда вы определяете функцию внутри другой функции.
>>2. **Доступ к переменным внешней функции**:
>>      - Внутренняя функция имеет доступ к переменным внешней функции.
>>3. **Сохранение состояния**:
>>     - Замыкания позволяют сохранять состояние между вызовами функций.
>>        Главное - ***сохранить ссылку на возвращаемый объект***, чтобы иметь доступ к методам и сохранить замыкание.
>>        У каждого присваивания будет свой скоуп.(см Пример Работы с разными вызовами)
>>> [!example]+ Примеры как сохраняется состояние и не сохраняется 
>>>```js
>>>function createCounter() {
>>>    let count = 0;    
>>>    return {
>>>        increment: function() {
>>>            count++;
>>>        },
>>>        getCount: function() {
>>>            return count;
>>>        }
>>>    };
>>>}
>>>```
>>> ###### Использование с присваиванием
>>>```js 
>>>const counter1 = createCounter();
>>>counter1.increment();
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 2
>>>```
>>>
>>> ***Использование как свойства объекта:***
>>>```js 
>>>const obj = {
>>>    counter: createCounter()
>>>};
>>>obj.counter.increment();
>>>console.log(obj.counter.getCount()); // Выведет: 1
>>>```
>>>
>>> ***Передача как аргумента функции:***
>>>```js 
>>>function useCounter(counter) {
>>>    counter.increment();
>>>    console.log(counter.getCount());
>>>}
>>>useCounter(createCounter()); // Выведет: 1
>>>```
>>> ###### Пример Работы с разными вызовами
>>>```js 
>>>const counter1 = createCounter();
>>>const counter2 = createCounter();
>>>
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 1
>>>console.log(counter2.getCount()); // Выведет: 0
>>>```
>>>###### Использование без присваивания
>>>```js 
>>>console.log(createCounter().getCount()); // Всегда выведет: 0
>>>createCounter().increment();
>>>console.log(createCounter().getCount()); // Все равно выведет: 0
>>>```
>
>>[!example]
>> ###### Пример простого замыкания:
>>```js
>>function outerFunction(x) {
>>    let y = 10;    
>>    function innerFunction() {
>>        console.log(x + y);
>>    }    
>>    return innerFunction;
>>}
>>const closure = outerFunction(5);
>>closure(); // Выведет: 15
>>```
>>
>>В этом примере `innerFunction` является замыканием. Она "запоминает" значения `x` и `y`, даже после того, как `outerFunction` завершила свое выполнение.
>> ###### Пример инкапсуляции и приватных переменных:
>>```js
>>function createCounter() {
>>    let count = 0;    
>>    return {
>>        increment: function() {
>>            count++;
>>        },
>>        getCount: function() {
>>            return count;
>>        }
>>    };
>>}
>>const counter = createCounter();
>>counter.increment();
>>counter.increment();
>>console.log(counter.getCount()); // Выведет: 2
>>console.log(counter.count); // Выведет: undefined
>>```
# каррирование
> [!help] 
>>[!quote]
>> **Каррирование (Currying)** - это техника в функциональном программировании, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает один аргумент. `funcName(1)(2)(3)`
>
> Основная идея каррирования заключается в том, чтобы сделать функции более гибкими и переиспользуемыми. Хотя каррирование не используется так часто, как некоторые другие паттерны, оно может быть очень полезным в определенных ситуациях.
>
>>[!example] Базовый пример каррирования:
>>```js 
>>// Обычная функция
>>function add(a, b, c) {
>>    return a + b + c;
>>}
>>
>>// Каррированная версия
>>function curriedAdd(a) {
>>    return function(b) {
>>        return function(c) {
>>            return a + b + c;
>>        }
>>    }
>>}
>>
>>console.log(add(1, 2, 3)); // 6
>>console.log(curriedAdd(1)(2)(3)); // 6
>>
>>// Частичное применение
>>const add1 = curriedAdd(1);
>>const add1And2 = add1(2);
>>
>>console.log(add1And2(3)); // 6
>>```

# прототипное наследование
> [!help] 
>>[!quote]
>**Прототипное наследование** в JS — это механизм, с помощью которого объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. Это позволяет избежать дублирования кода и позволяет объектам использовать свойства и методы своих "родителей".
> ###### Как работает прототипное наследование?
>>Когда ты пытаешься получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте.
>>Если свойство или метод не найдено, JavaScript продолжает поиск в прототипе объекта (то есть в объекте, от которого наследуется текущий объект).
>>Этот процесс продолжается до тех пор, пока не найдётся нужное свойство или не достигнут объект без прототипа (обычно это `null`).
>>>[!example] Пример базового прототипного наследования
>>>```javascript
>>> const animal = {
>>>  speak() {
>>>    return "Animal sound";
>>>  }
>>>};
>>>```
>>>```javascript
>>>const dog = {
>>>  bark() {
>>>    return "Woof!";
>>>  }
>>>};
>>>// Назначаем animal прототипом для dog
>>>Object.setPrototypeOf(dog, animal);
>>>
>>>console.log(dog.bark());   // "Woof!" - метод dog
>>>console.log(dog.speak());  // "Animal sound" - метод наследован от animal
>>
> ###### Методы для работы с прототипами
>> 1. **Object.setPrototypeOf()** - используется для назначения прототипа для объекта. Это современный и предпочтительный метод по сравнению с устаревшим `__proto__`.
>>>```javascript
>>>const animal = { legs: 4 };
>>>const cat = {};
>>>// Назначаем animal как прототип для cat
>>>Object.setPrototypeOf(cat, animal);
>>>
>>>console.log(cat.legs); // 4
>> 2. **Object.getPrototypeOf()** - возвращает прототип объекта, то есть объект, от которого он наследует.
>>>```javascript
>>>const proto = Object.getPrototypeOf(cat);
>>>console.log(proto); // { legs: 4 }
>>>console.log(proto === animal); // true
>>
> ###### Почему не используют `__proto__`
>>**`__proto__`** — это старый способ манипулирования прототипами, который считается небезопасным и неэффективным. Использование `Object.setPrototypeOf` и `Object.getPrototypeOf` предпочтительнее из-за лучшей производительности и поддержки стандартов.
>>```javascript
>>// Устаревший способ
>>cat.__proto__ = animal;
> ###### Изменение прототипа и его влияние
>>Когда ты изменяешь свойства или методы объекта-прототипа, это изменение отразится на всех объектах, которые используют этот объект в качестве прототипа.
>>```javascript
>>const bird = {
>>  fly() {
>>    return "Flying";
>>  }
>>};
>>
>>const eagle = {};
>>Object.setPrototypeOf(eagle, bird);
>>
>>console.log(eagle.fly()); // "Flying"
>>// Изменяем метод в прототипе
>>bird.fly = function() {
>>  return "Soaring!";
>>};
>>
>>console.log(eagle.fly()); // "Soaring!" - наследует изменённый метод
> ###### Примитивы и временные объектные обёртки
>>Примитивы, такие как строки и числа, при вызове методов временно преобразуются в объектные обёртки (String, Number и т.д.), что позволяет работать с методами этих типов данных. Можно добавлять свои методы в их прототипы.
>>>[!example] Пример с добавлением метода в String.prototype
>>>```javascript
>>>String.prototype.reverse = function() {
>>>  return this.split('').reverse().join('');
>>>};
>>>
>>>console.log("hello".reverse()); // "olleh"
> ###### **.prototype** и функции-конструкторы
>>**.prototype** — это специальное свойство функций-конструкторов, которое позволяет задавать методы и свойства для всех объектов, созданных через этот конструктор. Это не используется для обычных объектов.
>>```javascript
>>function Person(name) {
>>  this.name = name;
>>}
>>
>>Person.prototype.greet = function() {
>>  return `Hello, my name is ${this.name}`;
>>};
>>
>>const alice = new Person("Alice");
>>console.log(alice.greet()); // "Hello, my name is Alice"
> ###### Итоговое резюме:
>> **Прототипное наследование** — это механизм, который позволяет объектам наследовать свойства и методы от других объектов через цепочку прототипов.
>> - Используй `Object.setPrototypeOf(obj, proto)` для назначения прототипа объекта.
>> - Используй `Object.getPrototypeOf(obj)` для получения прототипа объекта.
>> - Не используй `__proto__` из-за его устаревшего статуса и низкой производительности.
>> - Изменения в объекте-прототипе отражаются на всех объектах, которые его используют.
>>`.prototype` используется для функций-конструкторов и классов, чтобы создавать общие методы для всех объектов, созданных через них.
>> - Примитивные типы данных, такие как строки и числа, временно преобразуются в объектные обёртки, что позволяет расширять их прототипы методами (например, добавление метода в `String.prototype`).

# this
> [!help] 
>>[!quote]
>>`this` - это ключевое слово, которое ссылается на контекст выполнения функции. 
>
>Значение `this` может меняться в зависимости от того, как функция вызывается.
> ###### Основные правила определения `this`: 
>>1. **Глобальный контекст**:
>>      - В браузере: `this` указывает на объект `window`
>>      - В Node.js: `this` указывает на глобальный объект `global`
>>2. **Внутри функции (простой вызов)**:
>>      - В строгом режиме `('use strict')`: `this` будет `undefined`
>>      - В нестрогом режиме: `this` будет глобальным объектом
>>3. **Метод объекта**:
>>      - `this` указывает на объект, который вызывает метод 
>>4. **Конструктор**:
>>      - `this` указывает на новосозданный объект 
>>5. **Стрелочные функции**:
>>      - `this` берется из окружающего лексического контекста
>
>>[!example] Глобальный контекст
>>```javascript
>>console.log(this); // window в браузере, global в Node.js
>>```
>
>>[!example] Простой вызов функции
>>```javascript
>>function simpleFunc() {
>>    console.log(this);
>>}
>>simpleFunc(); // window в браузере (нестрогий режим), undefined в строгом режиме
>>```
>
>>[!example] Метод объекта
>>```javascript
>>let obj = {
>>    method: function() {
>>        console.log(this);
>>    }
>>};
>>obj.method(); // {method: ƒ} в браузере
>>```
>
>>[!example] Конструктор
>>```javascript
>>function Constructor() {
>>    console.log(this);
>>}
>>new Constructor(); // новый объект Constructor {}
>>```
>
>>[!example] Стрелочная функция
>>```javascript
>>let arrowFunc = () => {
>>    console.log(this);
>>};
>>arrowFunc(); // window в браузере, global в Node.js
>>```
>
> ###### Методы изменения контекста: 
>>
>>>[!example] Вызывает функцию с заданным `this` и аргументами, переданными отдельно.
>>>```javascript
>>>function greet(greeting) {
>>>    console.log(greeting + ', ' + this.name);
>>>}
>>
>>>[!example]  **call()**
>>>```javascript
>>>let person = { name: 'John' };
>>>greet.call(person, 'Hello'); // "Hello, John"
>>>```
>>
>>>[!example] **apply()** - gохож на **call()**, но аргументы передаются массивом
>>>```javascript
>>>greet.apply(person, ['Hi']); // "Hi, John"
>>>```
>>
>>>[!example] **bind()** - cоздает новую функцию с привязанным контекстом.
>>>```javascript
>>>let boundGreet = greet.bind(person);
>>>boundGreet('Hey'); // "Hey, John"
>>>```
>>
> ###### Особые случаи: 
>>1. **События DOM (в браузере)**:
>>>[!example] `this` указывает на элемент, который вызвал событие
>>>```javascript
>>>document.querySelector('button').addEventListener('click', function() {
>>>    console.log(this); // <button> элемент
>>>});
>>>```
>>
>>2. **Стрелочные функции как методы:**:
>>>[!example] `this` будет `undefined` в стрелочной фукнции
>>>```javascript
>>>let obj = {
>>>    name: 'Object',
>>>    arrowMethod: () => {
>>>        console.log(this.name);
>>>    },
>>>    regularMethod: function() {
>>>        console.log(this.name);
>>>    }
>>>};
>>>
>>>obj.arrowMethod();   // undefined (this указывает на глобальный объект)
>>>obj.regularMethod(); // "Object"
>>>```
>>
>>
>>3. **`this` в присвоеннх переменных**:
>>>>[!example] основной обьект
>>>>```javascript
>>>>let person = {
>>>>    name: "John",
>>>>   sayHello: function() {
>>>>        return "Hello, my name is " + this.name;
>>>>    }
>>>>};
>>>
>>>>[!example] присваеваем в перменную, но без вызова - `undefined`
>>>>```javascript
>>>>const a = person.sayHello
>>>console.log(a()) // "Hello, my name is undefined"
>>>>```
>>>Здесь мы присваиваем функцию `person.sayHello` переменной `a` без вызова. Когда мы затем вызываем `a()`, это происходит в глобальном контексте (или в контексте `undefined` в строгом режиме). `this` внутри функции не ссылается на `person`, поэтому `this.name` становится `undefined`.
>>>
>>>>[!example] присваеваем в перменную и вызываем
>>>>```javascript
>>>>const b = person.sayHello()
>>>>console.log(b) // "Hello, my name is John"
>>>>```
>>>Здесь мы вызываем `person.sayHello()` сразу при присваивании. Функция выполняется в контексте объекта `person`, возвращает строку, и эта строка присваивается переменной `b`.
>>5. **`this` внутри внешнего API**:
>>>[!example] пример с `setTimeout` (это внешнее апи бразуера или ноды)
>>>```javascript
>>>const person ={
>>>  name:'Abdul',
>>>  greet: function(){
>>>    console.log(this) // window если браузер
>>>    console.log('Hello, my name is '+ this.name ) // Hello, my name is undefined
>>>  }
>>>}
>>>
>>>setTimeout(person.greet,100) 
>>>```
>>>
>>>Внешнее ***API***(пример `setTimeout`) имеет право устанавливать `this` как ему хочется в том случае, когда это допустимо ***спецификацией***.
А в ***спецификации*** это допустимо только при вызове `regular function`(не стрелочной) для котрой `this` не был установлен любым другим явным методом типо [`call bind apply`](#call-bind-apply)
>>>>[!info]- ссылка и место где это укащано в HTML5 спецификации
>>>>[ссылка](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers)
>>>>To perform the timer initialization steps, given a WindowOrWorkerGlobalScope global, a string or Function or TrustedScript handler, a number timeout, a list arguments, a boolean repeat, and optionally (and only if repeat is true) a number previousId, perform the following steps. They return a number.
>>>>1. ***Let thisArg be global if that is a WorkerGlobalScope object; otherwise let thisArg be the WindowProxy that corresponds to global.***
>>
> ###### Как понять что в `this`:
>>![[Pasted image 20240913123330.png]]

# call-bind-apply
> [!help] 
>>[!quote]
>>**call**, **bind** и **apply** - это методы в JS, которые позволяют манипулировать контекстом выполнения функции ([`this`](#this)) и передавать аргументы.
>---
>>>[!quote] **call()**
>>>**call()** вызывает функцию с заданным значением [`this`](#this) и индивидуально предоставленными аргументами.
>>Синтаксис: `function.call(thisArg, arg1, arg2, ...)`
>>
>>>[!example] 
>>>```js 
>>>const person = {
>>>    fullName: function(city, country) {
>>>        console.log(this.firstName + " " + this.lastName + " lives in " + city + ", " + country);
>>>    }
>>>}
>>>
>>>const person1 = {
>>>    firstName:"John",
>>>    lastName: "Doe"
>>>}
>>>
>>>person.fullName.call(person1, "New York", "USA");
>>>// Выведет: John Doe lives in New York, USA
>>>```
>>> В этом примере мы используем **call**, чтобы выполнить метод `fullName` объекта `person` в контексте объекта `person1`.
>>
>---
>>>[!quote] **apply()**
>>>**apply()** похож на **call()**, но принимает аргументы как массив.
>>>Синтаксис: `function.apply(thisArg, [argsArray])`
>>
>>>[!example] 
>>>```js 
>>>const person = {
>>>    introduce: function(greeting, punctuation) {
>>>        return greeting + ", I'm " + this.name + punctuation;
>>>    }
>>>};
>>>
>>>const john = { name: "John" };
>>>const mary = { name: "Mary" };
>>>
>>>console.log(person.introduce.apply(john, ["Hello", "!"])); // Выведет: "Hello, I'm John!"
>>>console.log(person.introduce.apply(mary, ["Hi", "?"])); // Выведет: "Hi, I'm Mary?"
>>>```
>>> Здесь **apply** позволяет нам использовать метод `introduce` с разными объектами, передавая аргументы в виде массива.
>>
>---
>>>[!quote] **bind()**
>>>**bind()** создает новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение.
>>>Синтаксис: `function.bind(thisArg, arg1, arg2, ...)`
>>>>[!info] Описание
>>>>Метод `bind()` создаёт новую ***"привязанную функцию"*** (ПФ). ПФ - это необычный функциональный объект ( термин из ECMAScript 6 ), который является обёрткой над исходным функциональным объектом. ***Вызов ПФ приводит к исполнению кода обёрнутой функции***.
>>
>>>[!example] 
>>>```js 
>>>const user = {
>>>    name: "Alice",
>>>    sayHello: function() {
>>>        console.log("Hello, I'm " + this.name);
>>>    }
>>>};
>>>
>>>const sayHelloFunc = user.sayHello;
>>>sayHelloFunc(); // Выведет: "Hello, I'm undefined"
>>>
>>>const boundSayHello = user.sayHello.bind(user);
>>>boundSayHello(); // Выведет: "Hello, I'm Alice"
>>>```
>>>В этом примере **bind** создает новую функцию с привязанным контекстом, что особенно полезно при передаче методов в качестве колбэков.
>>
>>>[!example] Примеры посложнее (последний пример самый адекватный!!!)
>>>```js 
>>>function greet(greeting, punctuation, time) {
>>>    console.log(`${greeting}, ${this.name}${punctuation} It's ${time}.`);
>>>}
>>>
>>>const person = { name: 'John' };
>>>
>>>// Привязываем контекст и один аргумент
>>>const boundGreet1 = greet.bind(person, 'Hello');
>>>boundGreet1('!', 'morning'); // Выводит: "Hello, John! It's morning."
>>>
>>>// Привязываем контекст и два аргумента
>>>const boundGreet2 = greet.bind(person, 'Hi', '.');
>>>boundGreet2('evening'); // Выводит: "Hi, John. It's evening."
>>>
>>>// Привязываем только контекст  ЧТО ВЫГЛЯДЕТ СУПЕР АДЕКВАТНО(сразу аргмуенты уже в фукнциию с баиндом)
>>>const boundGreet3 = greet.bind(person);
>>>boundGreet3('Hey', '?', 'night'); // Выводит: "Hey, John? It's night."
>>>```
>>>
>###### Основные различия:
>> - `call` и `apply` немедленно вызывают функцию, в то время как `bind` возвращает новую функцию.
>> - `call` принимает аргументы по отдельности, `apply` принимает их как массив.
>> - `bind` позволяет предустановить некоторые аргументы, создавая частично примененную функцию.
>###### Схематичное предствление написания
>> - **call**: `func.call(контекст, арг1, арг2, арг3, ...)`
>> - **apply**: `func.apply(контекст, [арг1, арг2, арг3, ...])`
>> - **bind**: `func.bind(контекст, [предустановленный_арг1, предустановленный_арг2, ...])`

# декораторы
> [!help] 
>>[!quote]
>>**Декоратор** —  это функция, которая принимает другую функцию и возвращает новую функцию, обычно с дополнительной функциональностью.
>>  - ***Основная идея декоратора*** - обернуть существующую функцию, не изменяя её код.
>###### Зачем нужны декораторы?
>>Они позволяют писать более чистый код, придерживаясь концепции композиции, и распространять единожды разработанную возможность на несколько функций и классов. Используя декораторы, вы сможете писать код, который проще отлаживать и сопровождать.
>>С декораторами код основной функции становится компактным, поскольку весь код, предназначенный для расширения ее возможностей, пишется за ее пределами. За счет декораторов можно добавлять в код новые возможности, не усложняя его.
>###### Примеры
>>[!example] Декоратор для логирования
>>```js 
>>function log(fn) {
>>  return function(...args) {
>>    console.log(`Вызвана функция: ${fn.name}`);
>>    return fn(...args);
>>  }
>>}
>>
>>function sayHello(name) {
>>  return `Привет, ${name}!`;
>>}
>>
>>const loggedSayHello = log(sayHello);
>>
>>console.log(loggedSayHello("Алиса"));
>>// Выведет:
>>// Вызвана функция: sayHello
>>// Привет, Алиса!
>>```
>>Здесь мы используем `...args` (оператор [`rest`](#rest-spread)), потому что:
>> - Мы хотим, чтобы декоратор `log` был универсальным и работал с любой функцией, независимо от количества аргументов.
>> - `...args` собирает все переданные аргументы в массив.
>> - Затем мы используем `fn(...args)` (оператор [`spread`](#rest-spread)), чтобы передать все эти аргументы в исходную функцию.
>> - Это позволяет декоратору `log` работать с функциями, принимающими любое количество аргументов, не зная заранее, сколько их будет.
>
>>[!example] Декоратор для проверки типов
>>```js 
>>function checkNumber(fn) {
>>  return function(x) {
>>    if (typeof x !== 'number') {
>>      throw new Error('Аргумент должен быть числом');
>>    }
>>    return fn(x);
>>  }
>>}
>>
>>function square(x) {
>>  return x * x;
>>}
>>
>>const checkedSquare = checkNumber(square);
>>
>>console.log(checkedSquare(5)); // 25
>>// checkedSquare("не число"); // Выбросит ошибку
>>```
>> Здесь мы используем `x`, потому что:
>> - Этот декоратор предназначен специально для функций, принимающих один числовой аргумент.
>> - Мы точно знаем, что проверяем и передаем только один аргумент.
>> - Использование конкретного параметра `x` делает код более читаемым и явно указывает на то, что ожидается только один аргумент.
> 
>>[!example] Декоратор для задержки выполнения
>>```js 
>>function delay(fn, ms) {
>>  return function(...args) {
>>    setTimeout(() => {
>>      fn(...args);
>>    }, ms);
>>  }
>>}
>>
>>function greet(name) {
>>  console.log(`Привет, ${name}!`);
>>}
>>
>>const delayedGreet = delay(greet, 1000);
>>
>>delayedGreet("Боб"); // "Привет, Боб!" после 1 секунды
>>```
> 
>>[!example] Декоратор для однократного выполнения
>>```js 
>>function once(fn) {
>>  let called = false;
>>  let result;
>>
>>  return function(...args) {
>>    if (!called) {
>>      result = fn(...args);
>>      called = true;
>>    }
>>    return result;
>>  }
>>}
>>
>>function initApp() {
>>  console.log("Приложение инициализировано");
>>}
>>
>>const initOnce = once(initApp);
>>
>>initOnce(); // "Приложение инициализировано"
>>initOnce(); // (ничего не выводит)
>>initOnce(); // (ничего не выводит)
>>```
> ###### Выбор между `...args` и `конкретным параметром` зависит от:
>> - ***Универсальности декоратора***: Нужно ли, чтобы он работал с функциями, принимающими разное количество аргументов?
>> - ***Специфики задачи***: Если декоратор предназначен для конкретного типа функций (например, с одним аргументом), можно использовать конкретный параметр.
>> - ***Читаемости кода***: Иногда явное указание параметров делает код более понятным.
>>
>>В общем случае, если вы хотите создать универсальный декоратор, который может работать с любыми функциями, используйте `...args`. Если декоратор предназначен для функций с определенным количеством аргументов, можно использовать конкретные параметры.
> 
# rest-spread
> [!help] 
>>>[!quote] **Rest(...)**
>>>**Rest(...)** оператор позволяет собрать несколько элементов в массив. Он используется в параметрах функций или в деструктуризации.
>> ###### Примеры
>>>[!example] В параметрах функции
>>>```js 
>>>function sum(...numbers) {
>>>  return numbers.reduce((total, num) => total + num, 0);
>>>}
>>>
>>>console.log(sum(1, 2, 3, 4)); // 10
>>>console.log(sum(5, 10, 15)); // 30
>>>```
>>
>>>[!example] В деструктуризации массива
>>>```js
>>>const [first, second, ...rest] = [1, 2, 3, 4, 5];
>>>console.log(first); // 1
>>>console.log(second); // 2
>>>console.log(rest); // [3, 4, 5]
>>>``` 
>>
>>>[!example] В деструктуризации объекта:
>>>```js
>>>const {name, age, ...otherInfo} = {name: "Алиса", age: 30, city: "Минск", job: "Программист"};
>>>console.log(name); // "Алиса"
>>>console.log(age); // 30
>>>console.log(otherInfo); // {city: "Минск", job: "Программист"}
>>>```
> ---
>>>[!quote] **Spread(...)**
>>>**Spread(...)** оператор "разворачивает" массив или объект на отдельные элементы. Он используется при вызове функций, создании новых массивов или объектов.** 
>> ###### Примеры
>>>[!example] При вызове функции
>>>```js
>>>function greet(first, second, third) {
>>>  console.log(`Привет, ${first}, ${second} и ${third}!`);
>>>}
>>>
>>>const names = ["Алиса", "Боб", "Чарли"];
>>>greet(...names); // "Привет, Алиса, Боб и Чарли!"
>>>``` 
>>
>>>[!example] При создании нового массива
>>>```js
>>>const arr1 = [1, 2, 3];
>>>const arr2 = [4, 5, 6];
>>>const combined = [...arr1, ...arr2];
>>>console.log(combined); // [1, 2, 3, 4, 5, 6]
>>>``` 
>>
>>>[!example] При создании копии массива
>>>```js
>>>const original = [1, 2, 3];
>>>const copy = [...original];
>>>console.log(copy); // [1, 2, 3]
>>>``` 
>>
>>>[!example] При работе с объектами
>>>```js
>>>const obj1 = {a: 1, b: 2};
>>>const obj2 = {c: 3, d: 4};
>>>const merged = {...obj1, ...obj2};
>>>console.log(merged); // {a: 1, b: 2, c: 3, d: 4}
>>>``` 
>>
>>>[!example] Для создания нового объекта с изменениями
>>>```js
>>>const person = {name: "Алиса", age: 30};
>>>const updatedPerson = {...person, age: 31};
>>>console.log(updatedPerson); // {name: "Алиса", age: 31}
>>>``` 

# строгое-и-нестрогое-равенсто
> [!help] 
>>[!quote] **==**
>>**Оператор == (нестрогое равенство)**
>> - Сравнивает значения с приведением типов.
>> - Если типы операндов различаются, JavaScript пытается привести их к общему типу перед сравнением.
>
>>[!quote] **===**
>>**Оператор === (строгое равенство)**
>> - Сравнивает значения без приведения типов.
>> - Возвращает `true` только если операнды имеют одинаковый тип и одинаковое значение.
>
>>[!example] Примеры
>>```js
>>// Сравнение чисел
>>console.log(5 == 5);   // true
>>console.log(5 === 5);  // true
>>
>>// Сравнение числа и строки
>>console.log(5 == "5");   // true (строка "5" приводится к числу 5)
>>console.log(5 === "5");  // false (разные типы)
>>
>>// Сравнение с булевыми значениями
>>console.log(1 == true);   // true (true приводится к 1)
>>console.log(1 === true);  // false (разные типы)
>>
>>// Сравнение с null и undefined
>>console.log(null == undefined);   // true
>>console.log(null === undefined);  // false
>>
>>// Сравнение объектов
>>let obj1 = {a: 1};
>>let obj2 = {a: 1};
>>let obj3 = obj1;
>>console.log(obj1 == obj2);   // false (разные объекты)
>>console.log(obj1 === obj2);  // false (разные объекты)
>>console.log(obj1 == obj3);   // true (тот же самый объект)
>>console.log(obj1 === obj3);  // true (тот же самый объект)
>>
>>// Особые случаи
>>console.log(0 == false);   // true
>>console.log(0 === false);  // false
>>console.log('' == false);  // true
>>console.log('' === false); // false
>>```
# логические-операторы
> [!help] 
>>[!quote] **Логические операторы в JS**
>> ***(Расположены по приоритету)*** 
>> - **!** (НЕ)
>> - **&&** (И)
>> - **||** (ИЛИ)
>> - **??** (Оператор нулевого слияния)
>
>>[!note] **Порядок приоритета операторов** (от высшего к низшему):
>> 1. **()** (скобки)
>> 2. **!** (логическое НЕ)
>> 3. ***, /, %** (умножение, деление, остаток)
>> 4. **+**, **-** (сложение, вычитание)
>> 5. **<**, **<=**, **>**, **>** **=** (сравнения)
>> 6. **==**, **!=**, **===**, **!==** (равенство/неравенство)
>> 7. **&&** (логическое И)
>> 8. **||** (логическое ИЛИ)
>> 9. **??** (оператор нулевого слияния)
>
>###### ! (НЕ)
>>>[!quote]
>>> - **Инвертирует булево значение операнда.**
>>> - **Приводит значение к булеву типу, затем инвертирует его.**
>>```js 
>>console.log(!true);  // false
>>console.log(!false);  // true
>>console.log(!0);  // true
>>console.log(!'');  // true
>>console.log(!1);  // false
>>console.log(!'hello');  // false
>>```
>
>###### && (И)
>>>[!quote]
>>> - **Возвращает `true`, если оба операнда истинны.**
>>> - **Возвращает первое ложное значение или последний операнд, если все истинны.**
>>```js 
>>console.log(true && true);  // true
>>console.log(true && false);  // false
>>console.log(false && true);  // false
>>console.log(false && false);  // false
>>console.log(1 && 2);  // 2
>>console.log(0 && 1);  // 0
>>console.log('a' && 'b');  // 'b'
>>console.log('' && 'b');  // ''
>>```
>
>###### || (ИЛИ)
>>>[!quote]
>>> - **Возвращает `true`, если хотя бы один операнд истинен.**
>>> - **Возвращает первое истинное значение или последний операнд, если все ложны.**
>>```js 
>>console.log(true || true);  // true
>>console.log(true || false);  // true
>>console.log(false || true);  // true
>>console.log(false || false);  // false
>>console.log(1 || 2);  // 1
>>console.log(0 || 1);  // 1
>>console.log('' || 'b');  // 'b'
>>console.log(null || undefined);  // undefined
>
>###### ?? (Оператор нулевого слияния)
>>>[!quote]
>>> - **Возвращает правый операнд, если левый операнд `null` или `undefined`.**
>>> - **В противном случае возвращает левый операнд.**
>>```js 
>>console.log(null ?? 'default');  // 'default'
>>console.log(undefined ?? 'default');  // 'default'
>>console.log(0 ?? 'default');  // 0
>>console.log('' ?? 'default');  // ''
>>console.log(false ?? 'default');  // false
>
>>[!info] Важно отметить
>> - Операторы **&&** и **||** используют короткозамкнутое вычисление. Это означает, что если результат может быть определен по первому операнду, второй операнд не вычисляется.
>> - Оператор **??** был добавлен в ECMAScript 2020 и может не поддерживаться в старых браузерах.
>> - При использовании нескольких операторов рекомендуется использовать скобки для явного указания порядка выполнения операций.
>###### Примеры
>>[!example] 
>>```js 
>>console.log(true && false || true && !false && (!true || false) && !(false || !true));
>>``` 
>>Разберем по шагам:
>>1. `!false = true`
>>2. `!true = false`
>>3. `(false || !true) = (false || false) = false`
>>4. `!(false || !true) = !false = true`
>>5. `true && false = false`
>>6. `true && true = true`
>>7. `false || true = true`
>>8. `true && false = false`
>>9. `false && true = false`
>>
>>Итоговый результат: ***false***
>
>>[!example] 
>>```js 
>>let a = 5, b = 10, c = 15;
>>console.log((a > b || b < c) && !(a > c) && (b - a > a - c || c % a === 0));
>>``` 
>>Разберем по шагам:
>>1. `a > b = false (5 > 10)`
>>2. `b < c = true (10 < 15)`
>>3. `(a > b || b < c) = (false || true) = true`
>>4. `a > c = false (5 > 15)`
>>5. `!(a > c) = !false = true`
>>6. `b - a = 5, a - c = -10`
>>7. `b - a > a - c = true (5 > -10)`
>>8. `c % a = 0 (15 % 5 = 0)`
>>9. `(b - a > a - c || c % a === 0) = (true || true) = true`
>>10. `true && true && true = true`
>>
>>Итоговый результат: ***true***
>
>>[!example] 
>>```js 
>>let x = null, y = undefined, z = '';
>>console.log((!x && y) || (z ?? 'default') !== '' && typeof x === typeof y);
>>```
>>Разберем по шагам:
>>
>>1. `!x = true (так как x = null)`
>>2. `(!x && y) = (true && undefined) = undefined`
>>3. `(z ?? 'default') = '' (так как z - пустая строка, а не null или undefined)`
>>4. `'' !== '' = false`
>>5. `typeof x = 'object' (в JS null имеет тип 'object')`
>>6. `typeof y = 'undefined'`
>>7. `typeof x === typeof y = false`
>>8. `false && false = false`
>>9. `undefined || false = false`
>>
>> Итоговый результат: ***false***
# typeof-разных-типов-данных
> [!help] 
>>[!quote] **Основные типы данных и результаты typeof**
>>```js 
>>console.log(typeof undefined);     // "undefined"
>>console.log(typeof null);          // "object"
>>console.log(typeof true);          // "boolean"
>>console.log(typeof 42);            // "number"
>>console.log(typeof "hello");       // "string"
>>console.log(typeof Symbol());      // "symbol"
>>console.log(typeof function(){});  // "function"
>>console.log(typeof {});            // "object"
>>console.log(typeof []);            // "object"
>>console.log(typeof NaN);           // "number"
>>console.log(typeof new Number(42));// "object"
>>```
###### Подводные камни и особенности:
>>[!info] **null**
>>```js 
>>console.log(typeof null);  // "object"
>>```
>>Это известная ошибка в JS, которая существует с самого начала. `null` не является объектом, но `typeof null` возвращает `"object"`. Это считается багом языка, который не может быть исправлен из-за обратной совместимости.
>
>>[!info] **Массивы**
>>```js 
>>console.log(typeof []);  // "object"
>>```
>>Массивы - это объекты, поэтому `typeof` возвращает `"object"`. Чтобы проверить, является ли что-то массивом, используйте `Array.isArray([])`
>>
>>```js 
>>console.log(Array.isArray([]));  // true
>>```
>
>>[!info] **NaN**
>>```js 
>>console.log(typeof NaN);  // "number"
>>```
>>`NaN` (Not a Number) парадоксально имеет тип `"number"`. Чтобы проверить на `NaN`, используйте `isNaN(NaN)`
>>```js 
>>console.log(isNaN(NaN));  // true
>>```
>
>>[!info] **Функции**
>>```js 
>>console.log(typeof function(){});  // "function"
>>```
>>Несмотря на то, что функции в JS являются объектами, `typeof` возвращает `"function"`.
>
>>[!info] **BigInt**
>>```js 
>>console.log(typeof 1n);  // "bigint"
>>```
>>BigInt - это относительно новый тип данных в JavaScript для работы с большими целыми числами.
>>
>
>>[!info] **Объекты-обертки**
>>```js 
>>console.log(typeof new Number(42));   // "object"
>>console.log(typeof new String("hi")); // "object"
>>console.log(typeof new Boolean(true));// "object"
>>```
>>Использование конструкторов создает объекты-обертки, а не примитивы.
>
>>[!info] **Неопределенные переменные**
>>```js 
>>console.log(typeof undeclaredVariable);  // "undefined"
>>```
>>`typeof` не вызывает ошибку для необъявленных переменных, что может быть полезно для проверки существования переменных.
>
>>[!info] **document** и **window**
>>```js 
>>console.log(typeof document);  // "object"
>>console.log(typeof window);    // "object"
>>```
>>Эти глобальные объекты браузера также имеют тип `"object"`.

# неявное-привидене-типов
> [!help] 
>>[!info] **undefined**
>>```js 
>>console.log(4 * undefined);  // NaN
>>console.log(4 + undefined);  // NaN
>>console.log(4 - undefined);  // NaN
>>console.log(4 / undefined);  // NaN
>>console.log(4 ** undefined); // NaN
>>console.log('4' + undefined); //4undefined
>>console.log('4' - undefined); //NaN
>>```
>>При арифметических операциях `undefined` преобразуется в `NaN`, что делает результат любой операции `NaN`.
>
>>[!info] **null**
>>```js 
>>console.log(4 * null);  // 0
>>console.log(4 + null);  // 4
>>console.log(4 - null);  // 4
>>console.log(4 / null);  // Infinity
>>console.log(4 ** null); // 1
>>console.log('4' + null);  // 4null
>>console.log('4' - null);  // 4
>>```
>>В арифметических операциях `null` преобразуется в `0`, кроме операции сложения, где он преобразуется в строку.
>
>>[!info] **Операции со строками**
>>```js
>>console.log("4" * 2);     // 8
>>console.log("4" + 2);     // "42"
>>console.log("4" - 2);     // 2
>>console.log("4" / 2);     // 2
>>console.log("4" ** 2);    // 16
>>console.log("hello" * 2); // NaN
>>```
>>JS пытается преобразовать `строки` в `числа`, когда это возможно. При сложении строка имеет приоритет, и происходит конкатенация.
>
>>[!info] **Операции с булевыми значениями**
>>```js
>>console.log(true + 1);        // 2
>>console.log(false + 1);       // 1
>>console.log(true * 5);        // 5
>>console.log(false * 5);       // 0
>>console.log(false * undefined); //NaN
>>console.log(false - undefined); //NaN
>>console.log(true + '1');         //true1
>>```
>>`true` преобразуется в `1`, `false` - в `0`.
>
>>[!info] **Операции с NaN**
>>```js
>>console.log(NaN + 1);  // NaN
>>console.log(NaN * 2);  // NaN
>>console.log(NaN / 3);  // NaN
>>console.log(NaN ** 0); // 1 (любое число в степени 0 равно 1)
>>```
>>Любая арифметическая операция с `NaN` дает `NaN`, кроме возведения в степень `0`.
>
>>[!info] **Операции с Infinity**
>>```js
>>console.log(Infinity + 1);  // Infinity
>>console.log(Infinity * 2);  // Infinity
>>console.log(Infinity / 3);  // Infinity
>>console.log(Infinity - Infinity); // NaN
>>console.log(Infinity / Infinity); // NaN
>>```
>
>>[!info] **Смешанные операции**
>>```js
>>console.log([] + {});     // "[object Object]"
>>console.log({} + []);     // 0 (в некоторых браузерах) или "[object Object]"
>>console.log([] + []);     // ""
>>console.log({} + {});     // "[object Object][object Object]"
>>console.log([] == !{});   // true
>>console.log([] == false); // true
>>console.log(!!{});        // true
>>console.log(!!0);         // false
>>```
>
>>[!info] **Операции с объектами**
>>```js
>>console.log({} + 1);        // "[object Object]1"
>>console.log([1,2,3] + 4);   // "1,2,34"
>>console.log([1] - 1);       // 0
>>console.log([1,2] - 1);     // NaN
>>```
>>1. `console.log([1,2,3] + 4);   // "1,2,34"`
>>      - ***Почему так***: Когда оператор `+` используется с `массивом`, JS сначала преобразует ***массив в строку***. Метод преобразования массива в строку соединяет все элементы через запятую. Таким образом, `[1,2,3]` становится строкой `"1,2,3"`. Затем происходит конкатенация этой строки с числом `4`, которое тоже преобразуется в строку. 
>>      - **Результат**: `"1,2,3"` + `"4"` = `"1,2,34"`.
>>
>>2. `console.log([1] - 1);       // 0`
>>      - ***Почему так***: При использовании оператора `-`, JS пытается преобразовать операнды в числа. Массив с одним числовым элементом `[1]` преобразуется в число `1`. Таким образом, операция становится эквивалентной `1` - `1`, что равно `0`.
>>
>>3. `console.log([1,2] - 1);     // NaN`
>>      - ***Почему так***: Здесь JS также пытается преобразовать ***массив в число***, но массив с более чем одним элементом не может быть напрямую преобразован в число. Попытка преобразования `[1,2]` в число дает `NaN`. Любая арифметическая операция с `NaN` всегда дает `NaN`.
>
>>Важно помнить, что многие из этих операций основаны на неявном приведении типов в JS. Хотя некоторые из них могут показаться нелогичными, они следуют определенным правилам языка. В профессиональной разработке рекомендуется избегать полагаться на такие неявные преобразования и использовать явное приведение типов для улучшения читаемости и предсказуемости кода.

# методы-массива
> [!help] 
>>[!info]- **push()**
>> - Добавляет элементы в конец массива
>> - Изменяет исходный массив
>> - Возвращает новую длину массива
>>```js
>>let arr = [1, 2];
>>let length = arr.push(3, 4);
>>console.log(arr);    // [1, 2, 3, 4]
>>console.log(length); // 4
>>```
>
>>[!info]- **pop()**
>> - Удаляет последний элемент из массива
>> - Изменяет исходный массив
>> - Возвращает удаленный элемент
>>```js
>>let arr = [1, 2, 3];
>>let last = arr.pop();
>>console.log(arr);  // [1, 2]
>>console.log(last); // 3
>>```
>
>>[!info]- **unshift()**
>> - Добавляет элементы в начало массива
>> - Изменяет исходный массив
>> - Возвращает новую длину массива
>>```js
>>let arr = [2, 3];
>>let length = arr.unshift(0, 1);
>>console.log(arr);    // [0, 1, 2, 3]
>>console.log(length); // 4
>>```
>
>>[!info]- **shift()**
>> - Удаляет первый элемент из массива
>> - Изменяет исходный массив
>> - Возвращает удаленный элемент
>>```js
>>let arr = [1, 2, 3];
>>let first = arr.shift();
>>console.log(arr);   // [2, 3]
>>console.log(first); // 1
>>```
>
>>[!info]- **flat()**
>>  - Разворачивает вложенные массивы в один уровень
>>  - Не изменяет исходный массив
>>  - Возвращает новый массив с развернутыми подмассивами
>>```js
>>let arr = [1, 2, [3, 4, [5, 6]]];
>>let flattened = arr.flat();
>>console.log(flattened); // [1, 2, 3, 4, [5, 6]]
>>
>>// С указанием глубины разворачивания
>>let deepFlattened = arr.flat(2);
>>console.log(deepFlattened); // [1, 2, 3, 4, 5, 6]
>>
>>// Полное разворачивание всех уровней
>>let completelyFlat = arr.flat(Infinity);
>>console.log(completelyFlat); // [1, 2, 3, 4, 5, 6]
>>```
>
>>[!info]- **concat()**
>> - Объединяет два или более массивов
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr1 = [1, 2];
>>let arr2 = [3, 4];
>>let newArr = arr1.concat(arr2);
>>console.log(newArr); // [1, 2, 3, 4]
>>console.log(arr1);   // [1, 2]
>>```
>
>>[!info]- **slice()**
>> - Возвращает часть массива
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let newArr = arr.slice(1, 4);
>>console.log(newArr); // [2, 3, 4]
>>console.log(arr);    // [1, 2, 3, 4, 5]
>>```
>
>>[!info]- **splice()**
>> - Изменяет содержимое массива, удаляя/заменяя существующие элементы и/или добавляя новые
>> - Изменяет исходный массив
>> - Возвращает массив удаленных элементов
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let removed = arr.splice(1, 2, 'a', 'b');
>>console.log(arr);     // [1, 'a', 'b', 4, 5]
>>console.log(removed); // [2, 3]
>>```
>>
>>>[!info] Возможности 
>>>```js
>>>splice(start, deleteCount, item1, item2, ...)
>>>```
>>>   - `start`: индекс, с которого начинать изменение
>>>   - `deleteCount`: количество элементов для удаления (необязательно)
>>>   - `item1, item2`, ...: элементы для добавления (необязательно)
>>>1. ***Добавление элементов***:
>>>>```js
>>>>let arr = [1, 2, 3];
>>>>arr.splice(1, 0, 'a', 'b');
>>>>console.log(arr); // [1, 'a', 'b', 2, 3]
>>>>```
>>>>Здесь мы добавляем `a` и `b` начиная с индекса `1`, не удаляя элементов.
>>>
>>>2. ***Замена элементов***:
>>>>```js
>>>>let arr = [1, 2, 3, 4];
>>>>arr.splice(1, 2, 'a', 'b');
>>>>console.log(arr); // [1, 'a', 'b', 4]
>>>>```
>>>>
>>>>Здесь мы заменяем `2` элемента начиная с индекса `1` на `a` и `b`.
>>>3. ***Удаление элементов***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>arr.splice(2, 2);
>>>>console.log(arr); // [1, 2, 5]
>>>>```
>>>>
>>>>Здесь мы удаляем `2` элемента начиная с индекса `2`.
>>>4. ***Удаление элементов до конца массива***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>arr.splice(2);
>>>>console.log(arr); // [1, 2]
>>>>```
>>>>
>>>>Если не указать `deleteCount`, удалятся все элементы от `start` до конца массива.
>>>5. ***Извлечение части массива без его изменения***:
>>>>```js
>>>>let arr = [1, 2, 3, 4, 5];
>>>>let extracted = arr.splice(2, 2);
>>>>console.log(extracted); // [3, 4]
>>>>console.log(arr);       // [1, 2, 5]
>>>>```
>>>>`splice()` возвращает массив удаленных элементов.
>
>>[!info]- **forEach()**
>> - Выполняет функцию для каждого элемента массива
>> - Не изменяет исходный массив (если только функция не изменяет элементы)
>> - Возвращает `undefined`
>>```js
>>let arr = [1, 2, 3];
>>arr.forEach(item => console.log(item * 2));
>>// Выводит: 2, 4, 6
>>```
>
>>[!info]- **map()**
>> - Создает новый массив с результатами вызова функции для каждого элемента
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3];
>>let newArr = arr.map(item => item * 2);
>>console.log(newArr); // [2, 4, 6]
>>console.log(arr);    // [1, 2, 3]
>>```
>
>>[!info]- **filter()**
>> - Создает новый массив с элементами, прошедшими проверку
>> - Не изменяет исходный массив
>> - Возвращает новый массив
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let evenArr = arr.filter(item => item % 2 === 0);
>>console.log(evenArr); // [2, 4]
>>console.log(arr);     // [1, 2, 3, 4, 5]
>>```
>
>>[!info]- **reduce()**
>> - Выполняет функцию для каждого элемента массива (слева-направо), сводя его к одному значению
>> - Не изменяет исходный массив
>> - Возвращает одно значение
>>```js
>>let arr = [1, 2, 3, 4];
>>let sum = arr.reduce((acc, curr) => acc + curr, 0);
>>console.log(sum);  // 10
>>console.log(arr);  // [1, 2, 3, 4]
>>```
>
>>[!info]- **find()**
>> - Возвращает первый элемент, удовлетворяющий условию
>> - Не изменяет исходный массив
>> - Возвращает элемент или undefined
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let found = arr.find(item => item > 3);
>>console.log(found); // 4
>>```
>
>>[!info]- **some()**
>> - Проверяет, удовлетворяет ли хотя бы один элемент условию
>> - Не изменяет исходный массив
>> - Возвращает `boolean`
>>```js
>>let arr = [1, 2, 3, 4, 5];
>>let hasEven = arr.some(item => item % 2 === 0);
>>console.log(hasEven); // true
>>```
>
>>[!info]- **every()**
>> - Проверяет, удовлетворяют ли все элементы условию
>> - Не изменяет исходный массив
>> - Возвращает `boolean`
>>```js
>>let arr = [2, 4, 6, 8];
>>let allEven = arr.every(item => item % 2 === 0);
>>console.log(allEven); // true
>>```
>
>>[!info]- **reverse()**
>> - Обращает порядок элементов в массиве
>> - Изменяет исходный массив
>> - Возвращает измененный массив
>>```js
>>let arr = [1, 2, 3];
>>arr.reverse();
>>console.log(arr); // [3, 2, 1]
>>```
>
>>[!info]- **sort()**
>> - Сортирует элементы массива
>> - Изменяет исходный массив
>> - Возвращает отсортированный массив
>>```js
>>let arr = [3, 1, 4, 1, 5];
>>arr.sort((a, b) => a - b);
>>console.log(arr); // [1, 1, 3, 4, 5]
>>```
>
>>[!info]- **join()**
>> - Объединяет все элементы массива в строку
>> - Не изменяет исходный массив
>> - Возвращает строку
>>```js
>>let arr = ['Hello', 'World'];
>>let str = arr.join(' ');
>>console.log(str); // "Hello World"
>>```
>
>>[!info]- **indexOf()**
>>  - Ищет элемент в массиве и возвращает его индекс
>>  - Не изменяет исходный массив
>>  - Возвращает индекс первого найденного элемента или `-1`, если элемент не найден
>>```js
>>let arr = [1, 2, 3, 2, 1];
>>let index = arr.indexOf(2);
>>console.log(index); // 1
>>
>>let notFound = arr.indexOf(4);
>>console.log(notFound); // -1
>>
>>// Поиск с указанной позиции
>>let laterIndex = arr.indexOf(2, 2);
>>console.log(laterIndex); // 3
>>```
>
>>[!info]- **includes()**
>> - Проверяет, содержит ли массив указанное значение и возвращает `true` или `false`.
>> - Не изменяет исходный массив.
>> - Выполняет строгое сравнение (`===`) для указанного элемента.
>>```js
>>let arr = [1, 2, 3, 2, 1];
>>let result = arr.includes(2);
>>console.log(result); // true
>>
>>let notFound = arr.includes(4);
>>console.log(notFound); // false
>>
>>// Поиск с указанной позиции
>>let laterResult = arr.includes(2, 2);
>>console.log(laterResult); // true
>>
>>// Поиск с отрицательным индексом
>>let resultFromEnd = arr.includes(1, -1);
>>console.log(resultFromEnd); // false
>>```

# методы-строк
> [!help] 
>>[!info]- **length**
>>Возвращает длину строки
>>Это свойство, а не метод
>>```js
>>let str = "Hello";
>>console.log(str.length); // 5
>>```
>
>>[!info]- **charAt()**
>>Возвращает символ по указанному индексу
>>```js
>>let str = "Hello";
>>console.log(str.charAt(1)); // "e"
>>```
>
>>[!info]- **charCodeAt()**
>>Возвращает Unicode символа по указанному индексу
>>```js
>>let str = "Hello";
>>console.log(str.charCodeAt(0)); // 72
>>```
>
>>[!info]- **concat()**
>>Объединяет две или более строки
>>```js
>>let str1 = "Hello";
>>let str2 = "World";
>>console.log(str1.concat(" ", str2)); // "Hello World"
>>```
>
>>[!info]- **indexOf()**
>>Возвращает индекс первого вхождения подстроки
>>```js
>>let str = "Hello World";
>>console.log(str.indexOf("World")); // 6
>>```
>
>>[!info]- **lastIndexOf()**
>>Возвращает индекс последнего вхождения подстроки
>>```js
>>let str = "Hello World World";
>>console.log(str.lastIndexOf("World")); // 12
>>```
>
>>[!info]- **slice()**
>>Извлекает часть строки и возвращает новую строку
>>```js
>>let str = "Hello World";
>>console.log(str.slice(6)); // "World"
>>console.log(str.slice(0, 5)); // "Hello"
>>```
>
>>[!info]- **substring()**
>>Извлекает символы между двумя индексами строки
>>```js
>>let str = "Hello World";
>>console.log(str.substring(6, 11)); // "World"
>>```
>
>>[!info]- **substr()**
>>Извлекает указанное количество символов с указанной позиции
>>```js
>>let str = "Hello World";
>>console.log(str.substr(6, 5)); // "World"
>>```
>
>>[!info]- **toLowerCase()**
>>Преобразует строку в нижний регистр
>>```js
>>let str = "Hello World";
>>console.log(str.toLowerCase()); // "hello world"
>>```
>
>>[!info]- **toUpperCase()**
>>Преобразует строку в верхний регистр
>>```js
>>let str = "Hello World";
>>console.log(str.toUpperCase()); // "HELLO WORLD"
>>```
>
>>[!info]- **trim()**
>>Удаляет пробельные символы с начала и конца строки
>>```js
>>let str = "  Hello World  ";
>>console.log(str.trim()); // "Hello World"
>>```
>
>>[!info]- **replace()**
>>Заменяет указанное значение другим значением в строке
>>```js
>>let str = "Hello World";
>>console.log(str.replace("World", "JavaScript")); // "Hello JavaScript"
>>```
>
>>[!info]- **split()**
>>Разбивает строку на массив подстрок
>>```js
>>let str = "Hello,World,JavaScript";
>>console.log(str.split(",")); // ["Hello", "World", "JavaScript"]
>>```
>
>>[!info]- **startsWith()**
>>Проверяет, начинается ли строка с указанных символов
>>```js
>>let str = "Hello World";
>>console.log(str.startsWith("Hello")); // true
>>```
>
>>[!info]- **endsWith()**
>>Проверяет, заканчивается ли строка указанными символами
>>```js
>>let str = "Hello World";
>>console.log(str.endsWith("World")); // true
>>```
>
>>[!info]- **includes()**
>>Проверяет, содержит ли строка указанную подстроку
>>```js
>>let str = "Hello World";
>>console.log(str.includes("World")); // true
>>```
>
>>[!info]- **repeat()**
>>Возвращает новую строку с указанным числом копий исходной строки
>>```js
>>let str = "Hello";
>>console.log(str.repeat(3)); // "HelloHelloHello"
>>```
>
>>[!info]- **padStart()**
>>Дополняет текущую строку другой строкой до заданной длины с начала
>>```js
>>let str = "5";
>>console.log(str.padStart(3, "0")); // "005"
>>```
>
>>[!info]- **padEnd()**
>>Дополняет текущую строку другой строкой до заданной длины с конца
>>```js
>>let str = "5";
>>console.log(str.padEnd(3, "0")); // "500"
>>```


# event-loop
