# JS
> [!help] 
> 
>JavaScript - это:
>1. **Высокоуровневый язык программирования  **  
>    - Абстрагирован от машинного кода, более близок к человеческому языку.
>      > [!info]-
>      > JavaScript можно использовать для иллюстрации принципа ***абстракции*** в  ([[ООП]]). Абстракция позволяет нам работать с объектами через их интерфейсы, скрывая внутреннюю реализацию и сложность.
>    - Обеспечивает автоматическое управление памятью (сборка мусора).
>2. **Динамически типизируемый **   
>    - Типы переменных определяются во время выполнения.
>    - Переменная может хранить значения разных типов в разное время.
>3. **Слабо типизированный**    
>    - Допускает неявное приведение типов.
>4. **Интерпретируемый**    
>    - Код выполняется построчно без предварительной компиляции.
>   > [!info]- 
>   >###### Построчное выполнение:
>   >   - Интерпретатор проходит по коду один раз, выполняя каждую инструкцию по порядку.
>   >###### Процесс выполнения:
>   >   - Код загружается и анализируется (парсится).
>   >   - Затем он выполняется сверху вниз, инструкция за инструкцией.
>   >   - После выполнения всех инструкций программа завершается, если нет бесконечных циклов или событийных слушателей.
>   >###### Контекст веб-страницы:
>   >   - В браузере JavaScript не "крутится" постоянно после загрузки страницы.
>   >   - Вместо этого, после выполнения начального кода, движок JavaScript ожидает событий (клики, таймеры и т.д.).
>   >###### Событийный цикл ([Event Loop](#event-loop)):
>   >   - JavaScript использует событийную модель.
>   >   - После выполнения начального кода, движок входит в состояние ожидания событий.
>   >   - Когда происходит событие, соответствующий обработчик выполняется.
>   >###### Память и выполнение:
>   >   - Интерпретатор не "запоминает" код в том смысле, в котором это делает компилятор.
>   >   - Однако, современные движки JavaScript (как V8) могут кэшировать результаты парсинга и даже компилировать часто используемый код (JIT-компиляция).
>   >###### Глобальный контекст:
>   >   - Глобальные переменные и функции остаются в памяти, пока страница открыта.
>   >   - Это позволяет обращаться к ним из обработчиков событий в любое время.
>    - Современные движки JS используют JIT-компиляцию для оптимизации производительности.
>   > [!info]- 
>   >JIT (Just-In-Time) подход позволяет JavaScript в Chrome быстро начинать выполнение (благодаря интерпретации) и достигать высокой производительности для критических участков кода (благодаря оптимизирующей компиляции).
>   > **JIT (Just-In-Time)** компиляция в V8 -  включает несколько уровней оптимизации. Вот как это работает в общих чертах:
>   >1. ***Интерпретация***:   
>   >    - Сначала весь код интерпретируется построчно интерпретатором Ignition.
>   >2. ***Профилирование***:    
>   >    - Во время выполнения V8 собирает информацию о том, как часто выполняются различные части кода и какие типы данных используются.
>   >3. ***Базовая JIT-компиляция***:    
>   >    - Часто выполняемые функции компилируются в машинный код компилятором TurboFan.
>   >    - Этот код быстрее интерпретируемого, но еще не полностью оптимизирован.
>   >4. ***Оптимизирующая компиляция***:    
>   >    - Для "горячего" кода (очень часто выполняемого) применяется агрессивная оптимизация.
>   >   - Здесь используется собранная информация о типах и поведении кода для создания высокооптимизированного машинного кода.
>   >5. ***Деоптимизация***:   
>   >    - Если предположения, сделанные при оптимизации, оказываются неверными (например, тип переменной изменился), код "деоптимизируется" и возвращается к менее оптимизированной версии или к интерпретации.
>   >6. ***Адаптивная оптимизация***:    
>   >    - V8 продолжает мониторить выполнение и может повторно оптимизировать код, если паттерны использования изменяются.
>   > ###### Ключевые моменты:
>   >>- Не весь код компилируется. Редко используемый код может остаться интерпретируемым.
>   >>- Компиляция происходит параллельно с выполнением программы.
>   >>- Уровень оптимизации зависит от частоты использования кода и стабильности типов.
>   >>- V8 балансирует между скоростью запуска (интерпретация) и скоростью выполнения (компиляция).
>  
>5. **Встраиваемый**    
>    - Может быть встроен в веб-браузеры и другие хост-среды (например, Node.js).
>    - Не имеет собственного ввода/вывода, полагается на хост-среду для этих функций.
>6. **Мультипарадигменный**   
>    - Поддерживает процедурное, объектно-ориентированное и функциональное программирование.
>      > [!info]- 
>      > ###### Основные парадигмы программирования:
>      >>1. ***Императивное программирование***
>      >>    - Процедурное программирование
>      >>    - Объектно-ориентированное программирование ([[ООП]])
>      >>2. ***Декларативное программирование ***   
>      >>    - Функциональное программирование
>      >>    - Логическое программирование
>      >>3. ***Структурное программирование***    
>      >>4. ***Событийно-ориентированное программирование***  
>      >>5. ***Аспектно-ориентированное программирование***    
>      >>6. ***Прототипно-ориентированное программирование***    
>      >>7. ***Компонентно-ориентированное программирование***    
>      >>8. ***Параллельное программирование***
>      >>9. ***Реактивное программирование***   
>      > ###### Парадигмы, которые хорошо подходят для JavaScript и широко в нем используются:
>      >>1. ***Процедурное программирование***:  
>      >>    JavaScript позволяет писать последовательные инструкции и организовывать код в функции.   
>      >>    ```js
>      >>    function calculateArea(width, height) {
>      >>        return width * height;
>      >>    }
>      >>      
>      >> 2. ***Объектно-ориентированное программирование***:  
>      >>    JavaScript поддерживает ООП как через прототипы, так и через классы (с ES6).  
>      >>    ```js
>      >>    class Rectangle {
>      >>        constructor(width, height) {
>      >>           this.width = width;
>      >>            this.height = height;
>      >>        }
>      >>        
>      >>        getArea() {
>      >>            return this.width * this.height;
>      >>        }
>      >>    }
>      >>    ```   
>      >>3. ***Функциональное программирование***:  
>      >>    JavaScript поддерживает функции первого класса, замыкания и другие функциональные концепции.    
>      >>    ```js
>      >>   const multiply = (a, b) => a * b;
>      >>    const numbers = [1, 2, 3, 4, 5];
>      >>    const doubled = numbers.map(n => n * 2);
>      >>    ```    
>      >>4. ***Прототипно-ориентированное программирование***:  
>      >>    Это основной механизм наследования в JavaScript.   
>      >>    ```js
>      >>    function Animal(name) {
>      >>        this.name = name;
>      >>    }
>      >>    Animal.prototype.speak = function() {
>      >>        console.log(this.name + ' makes a noise.');
>      >>    };
>      >>    ```
>      >>   
>      >>5. ***Событийно-ориентированное программирование***:  
>      >>    Широко используется в JavaScript, особенно в веб-разработке.
>      >>    ```
>      >>    document.getElementById('myButton').addEventListener('click', function() {
>      >>        console.log('Button clicked!');
>      >>    });
>      >>    ```  
>      >>6. ***Компонентно-ориентированное программирование***:  
>      >>    Популярно в современных фреймворках, таких как React, Vue, Angular.
>      >>    ```ts
>      >>   // Пример React-компонента
>      >>    function Welcome(props) {
>      >>        return <h1>Hello, {props.name}</h1>;
>      >>    }
>      >>    ```   
>      >>7. ***Реактивное программирование***:  
>      >>    Поддерживается через библиотеки, такие как RxJS.
>      >>    ```js
>      >>    // Пример с использованием RxJS
>      >>    import { fromEvent } from 'rxjs';
>      >>    import { map } from 'rxjs/operators';
>      >>    
>      >>    const clicks = fromEvent(document, 'click');
>      >>    const positions = clicks.pipe(map(ev => ev.clientX));
>      >>    positions.subscribe(x => console.log(x));
>      >>    ```   
>      >>8. ***Асинхронное программирование***:  
>      >>    JavaScript отлично поддерживает асинхронное программирование через callbacks, promises и async/await.
>      >>    ```js
>      >>    async function fetchData() {
>      >>       try {
>      >>            const response = await fetch('https://api.example.com/data');
>      >>            const data = await response.json();
>      >>            console.log(data);
>      >>        } catch (error) {
>      >>            console.error('Fetching error:', error);
>      >>        }
>      >>    }
>      >>    ```
>      >> ###### Заключение:  
>      >>>JavaScript действительно является мультипарадигменным языком, поддерживающим множество различных подходов к программированию. Это дает разработчикам большую гибкость в выборе наиболее подходящего стиля для конкретной задачи или проекта. Наиболее часто в JavaScript используются процедурное, объектно-ориентированное и функциональное программирование, но язык также хорошо поддерживает событийно-ориентированное, компонентно-ориентированное и реактивное программирование. Выбор парадигмы часто зависит от конкретных требований проекта, личных предпочтений разработчика и используемых фреймворков или библиотек.
>      > 
>      > 
>  
>7. **Прототипно-ориентированный**    
>    - Использует прототипы для наследования, в отличие от классического [[ООП]].
>8. **Однопоточный с асинхронностью**    
>    - Имеет однопоточную модель выполнения.
>    - Поддерживает асинхронное программирование через callbacks, Promises и async/await.
>9. **Кроссплатформенный**   
>    - Работает на различных платформах и устройствах.
>10. **С поддержкой функций первого класса**    
>       - Функции могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
>       - 

# типы-данных
> [!help] 
> В JavaScript есть **8** основных типов данных:
>1. **Number** (число)
>    - Включает целые числа и числа с плавающей точкой.
>    - Пример: 42, 3.14
>2. **String** (строка)    
>    - Текстовые данные.
>    - Пример: "Hello", 'World'
>3. **Boolean** (логический тип)    
>    - true или false
>4. **Undefined**    
>    - Представляет переменную, которой не присвоено значение.
>    - ***typeof undefined*** возвращает ***"undefined"***
>5. **Null**   
>    - Представляет намеренное отсутствие какого-либо объектного значения.
>    - В отличие от undefined, null всегда присваивается намеренно.
>    - null используется для явного указания на отсутствие значения или "пустоту".
>    - ***typeof null*** возвращает ***"object"***
>6. **Object** (объект)    
>    - Коллекция свойств.
>    - Пример: {name: "John", age: 30}
>7. **Symbol** (символ)    
>    - Уникальный идентификатор.
>    - Введен в ECMAScript 6.
>8. **BigInt**    
>    - Для работы с целыми числами произвольной длины.
>    - Введен в ECMAScript 2020.
>    - Пример: 1234567890123456789012345678901234567890n
> ###### Важные замечания:
>>1. **Массивы и функции**:    
>>    - Технически, массивы (Array) и функции (Function) являются подтипами Object. Но их часто рассматривают как отдельные типы из-за их особого поведения.
>>2. **Примитивные типы**:    
>>    - Number, String, Boolean, Undefined, Null, Symbol и BigInt считаются примитивными типами.
>>    - Object - это непримитивный тип.
>>3. **Специальные объекты**:    
>>    - Date, RegExp, Error и другие встроенные объекты часто упоминаются при обсуждении типов данных, но они являются подтипами Object.
>>4. **typeof оператор**:    
>>    - Оператор typeof может возвращать следующие строки: "number", "string", "boolean", "undefined", "object", "function", "symbol", "bigint".
>>    - Обратите внимание, что typeof null возвращает "object", что считается исторической ошибкой в языке.
>  

# var-let-const
> [!help] 
> 1. **var**:   
>    - [Функциональная область видимости](#области-видимости) 
>         - если объявлена вне функции, то имеет [глобальную область видимости](#области-видимости).
>    - [Поднятие (hoisting)](#поднятие(hosting)) `var` поднимается и инициализируется значением undefined
>    - Можно переопределять
>    - Существует с начала JavaScript
>2. **let**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (точнее, есть "временная мертвая зона"), поднимаются, но не инициализируются
>    - Можно переопределять
>    - Введено в ES6 (2015)
>3. **const**:   
>    - [Блочная область видимости](#области-видимости)
>         - если объявлены вне любого блока, имеют [глобальную область видимости](#области-видимости) (***но не становятся свойствами глобального объекта***).
>    - [Нет поднятия](#поднятие(hosting)) (как и `let`), поднимаются, но не инициализируются
>    - Нельзя переопределять (но можно изменять содержимое объектов)
>    - Введено в ES6 (2015)
>  
>  > [!example] 
>   >> Если `var` объявлена вне функции, она становится глобальной переменной и свойством глобального объекта (`window` в браузере).
>   >> ```js
>   >>var globalVar = "I'm global";
>   >>console.log(window.globalVar); // "I'm global" (в браузере)
>   >>console.log(globalVar);        // "I'm global" (в браузере)
>   >>```
>   >>Переменная `globalVar`, объявленная с помощью `var`, становится как глобальной переменной, так и свойством объекта `window`. Поэтому мы можем обращаться к ней обоими способами.
>   > ---
>   >>Если `let` или `const` объявлены вне любого блока (в глобальной области), они становятся глобальными переменными, но не становятся свойствами глобального объекта.
>   >> ```js
>   >>let globalLet = "I'm global";
>   >>const globalConst = "I'm also global";
>   >>console.log(window.globalLet);    // undefined (в браузере)
>   >>console.log(window.globalConst);  // undefined (в браузере)
>   >>console.log(globalLet);    // "I'm global" (в браузере)
>   >>console.log(globalConst);  // "I'm also global" (в браузере)
>   >>```
>   >> Переменные `globalLet` и `globalConst`, хотя и являются глобальными (доступны во всем скрипте), не становятся свойствами объекта `window`. Поэтому мы можем обращаться к ним напрямую, но не через window.
>
>  > [!info] 
>> Теоретические причины, по которым var может быть быстрее:
>>1. Отсутствие проверки временной мертвой зоны (TDZ):    
>>    - let и const имеют временную мертвую зону, var - нет.
>>    - Движок JS должен проверять, не находится ли переменная в TDZ при каждом обращении к ней.
>>2. Более простая область видимости:    
>>    - var имеет функциональную область видимости.
>>    - let и const имеют блочную область видимости, что может требовать более сложной логики для отслеживания.
>>3. Поднятие (hoisting):   
>>    - var поднимается и инициализируется значением undefined.
>>    - let и const поднимаются, но не инициализируются, что требует дополнительных проверок. 
>>      
# области-видимости

> [!help] 
>> [!quote] 
>>  - **Глобальная область видимости** - Это самый внешний уровень области видимости. Переменные, объявленные здесь, доступны во всем скрипте.
>
>> [!quote] 
>>  - **Функциональная область видимости** -  Переменные, объявленные внутри функции, доступны только внутри этой функции.
>
>> [!quote] 
>>  - **Блочная область видимости** - Переменные доступны только внутри блока, где они объявлены.
>  
# поднятие(hosting)
> [!help] 
> > [!quote] 
> **Hoisting** (поднятие) — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их [области видимости](#области-видимости) во время выполнения кода. Это позволяет использовать переменные и функции до их фактического объявления в коде.  
> ###### Hoisting переменных
>> 1. **Переменные, объявленные с помощью `var`**:  
>>    - Объявление переменной поднимается, но инициализация остаётся на месте.         
>>        ```javascript
>>        console.log(x); // undefined
>>        var x = 5;
>>        console.log(x); // 5
>>        ```     
>2. **Переменные, объявленные с помощью `let` и `const`**:
>>   
>>    - Объявление переменной поднимается, но она не инициализируется. Доступ к переменной до её объявления вызывает ошибку.
>>    - Пример:      
>>        ```javascript
>>        console.log(y); // ReferenceError: Cannot access 'y' before initialization
>>        let y = 10;
>>        ```
>> ###### Пример с глобальной и локальной переменными
>>>```js 
>>>function scope() {
>>>  a = 42;
>>>  var b = 43;
>>>}
>>>scope();
>>>console.log(a); // 42
>>>console.log(b); // ReferenceError: b is not defined
>>>```
>> Так как переменная `a` не была объявлена, то JavaScript сам решил, где объявлять переменную, и «поднял» объявление наверх. Получился вот такой код:
>>>```js 
>>>var a
>>>function scope() {
>>>  a = 42
>>>  var b = 43
>>>}
>>>scope()
>>>console.log(a)
>>>// 42
> >
> ###### Hoisting функций
> > 1. **Функции, объявленные с помощью `function`**:
> >    - Объявление и определение функции поднимаются, что позволяет вызывать функцию до её объявления.
> >        ```javascript
> >        catName("Тигр"); // "Мою кошку зовут Тигр"        
> >        function catName(name) {
> >          console.log("Мою кошку зовут " + name);
> >        }
> >        ```       
> >2. **Функции, присвоенные переменной**:    
> >    - Объявление переменной поднимается, но инициализация функцией не поднимается. Попытка вызвать функцию до её инициализации вызывает ошибку.
> >        ```javascript
> >        console.log(catName); // undefined
> >        catName("Тигр"); // TypeError: catName is not a function        
> >        var catName = function(name) {
> >          console.log("Мою кошку зовут " + name);
> >        };
>> 
>
> > [!summary]
>***Hoisting*** в JavaScript поднимает объявления переменных и функций в начало их области видимости. Это позволяет использовать их до фактического объявления в коде, но важно помнить, что инициализация переменных не поднимается. Переменные, объявленные с помощью `let` и `const`, ведут себя иначе и не доступны до их инициализации.      
# объявления-функций
> [!help] 
>###### Function Declaration (Объявление функции)
>>```js
>>function greet(name) {
>>    console.log(`Hello, ${name}!`);
>>}
>>greet("Alice"); // Выведет: Hello, Alice! 
>>```
>>**Особенности**:
>>- Поднимается [(hoisting)](#поднятие(hosting)) в начало своей области видимости.
>>- Можно вызвать до объявления в коде.
>>- Имеет свой собственный `this`.
>>
>>**Контекст**(`this`):
>>***Function Declaration*** создает свой собственный контекст выполнения. Значение `this` внутри такой функции зависит от того, как она вызывается.
>>```js
>>const obj = {
>>    name: "John",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm John
>>const hi = obj.sayHi;
>>hi(); // Выведет: Hi, I'm undefined (в нестрогом режиме) или выбросит ошибку (в строгом режиме)
>>```
> ###### Function Expression (Функциональное выражение)
>>```js
>>const greet = function(name) {
>>    console.log(`Hello, ${name}!`);
>>};
>>greet("Bob"); // Выведет: Hello, Bob!
>>```
>>**Особенности**:
>> - Не поднимается (no hoisting).
>> - Нельзя вызвать до объявления в коде.
>> - Может быть анонимной или именованной.
>> - Имеет свой собственный `this`.
>>
>>**Контекст**:
>>***Function Expression***, как и ***Function Declaration***, создает свой собственный контекст выполнения.
>>```js
>>const obj = {
>>    name: "Sarah",
>>    sayHi: function() {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm Sarah
> ###### Arrow Function (Стрелочная функция)
>>```js
>>const greet = (name) => {
>>    console.log(`Hello, ${name}!`);
>>};
>>
>>greet("Charlie"); // Выведет: Hello, Charlie!
>>```
>>**Особенности**:
>> - Более краткий синтаксис.
>> - Не имеет собственного `this`.
>> - Не может быть использована как конструктор.
>> - Не имеет собственного `arguments`.
>>> [!customname]- Что еще за `arguments`
>>> В JS, традиционные функции (***Function Declaration*** и ***Function Expression***) имеют доступ к специальному объекту `arguments`. Этот объект содержит все аргументы, переданные функции, даже если они не были объявлены в списке параметров.
>>>```js
>>>function regularFunction() {
>>>   console.log(arguments);
>>>   console.log(arguments.length);
>>>   console.log(arguments[0]);
>>>}
>>>regularFunction(1, 'a', true);
>>>// Выведет:
>>>// [1, 'a', true]
>>>// 3
>>>// 1
>>>```
>>> Однако стрелочные функции не имеют собственного `arguments`. Если вы попытаетесь получить доступ к arguments внутри стрелочной функции, вы получите `arguments` из внешней (не стрелочной) функции, если такая есть, или ошибку, если внешней функции нет.
>>>
>>>---
>>>
>>>**Пример со стрелочной функцией:**
>>>```js
>>>const arrowFunction = () => {
>>>    console.log(arguments);
>>>};
>>>arrowFunction(1, 'a', true);
>>>// Выбросит ошибку: ReferenceError: arguments is not defined
>>>```
>>>**Пример вложенной стрелочной функции:**
>>>```js
>>>function outerFunction() {
>>>    const arrowFunction = () => {
>>>        console.log(arguments);
>>>    };
>>>    arrowFunction(1, 'a', true);
>>>}
>>>outerFunction(4, 5, 6);
>>>// Выведет: [4, 5, 6]
>>>// Заметьте, что это аргументы внешней функции, а не стрелочной
>>
>> **Контекст**:
>>Arrow Function не создает свой собственный контекст выполнения. Вместо этого она захватывает `this` из окружающего лексического контекста.
>>```js
>>const obj = {
>>    name: "Mike",
>>    sayHi: () => {
>>        console.log(`Hi, I'm ${this.name}`);
>>    }
>>};
>>obj.sayHi(); // Выведет: Hi, I'm undefined
>>```
>
>**Пример, демонстрирующий разницу в контексте**:
>>> [!example] 
>>>```js
>>>  const obj = {
>>>    name: "Alice",
>>>    sayHiRegular: function() {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    },
>>>    sayHiArrow: () => {
>>>        console.log(`Hi, I'm ${this.name}`);
>>>    }
>>>};
>>>obj.sayHiRegular(); // Выведет: Hi, I'm Alice
>>>obj.sayHiArrow();   // Выведет: Hi, I'm undefined
>>>```
>>> **Использование в callback'ах**
>>>```js
>>>const objWithCallback = {
>>>    name: "Bob",
>>>    friends: ["Alice", "Charlie"],
>>>    greetFriendsRegular: function() {
>>>        this.friends.forEach(function(friend) {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь не ссылается на objWithCallback
>>>        });
>>>    },
>>>    greetFriendsArrow: function() {
>>>        this.friends.forEach((friend) => {
>>>            console.log(`${this.name} greets ${friend}`); // this здесь ссылается на objWithCallback
>>>       });
>>>    }
>>>};
>>>objWithCallback.greetFriendsRegular(); // Выведет: undefined greets Alice, undefined greets Charlie
>>>objWithCallback.greetFriendsArrow();   // Выведет: Bob greets Alice, Bob greets Charlie
>>>```
>>>
>>>**Основные различия**:
>>> - ***Function Declaration*** поднимается, ***Function Expression*** и ***Arrow Function*** - нет.
>>> - ***Arrow Function*** не имеет собственного `this`, в отличие от других типов функций.
>>> - ***Arrow Functio***n имеет более краткий синтаксис.
>>> - ***Function Declaration*** и ***Function Expression*** могут быть использованы как конструкторы, ***Arrow Function*** - нет.
>
# замыкание
> [!help] 
>>[!quote]
>> **Замыкание**(Closure) - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Другими словами, это способность функции запоминать и получать доступ к переменным из внешней по отношению к ней области видимости, даже когда функция выполняется вне этой области видимости.
>
> ###### Ключевые аспекты замыканий:
>> 1. **Функция внутри функции**:
>>      - Замыкание обычно создается, когда вы определяете функцию внутри другой функции.
>>2. **Доступ к переменным внешней функции**:
>>      - Внутренняя функция имеет доступ к переменным внешней функции.
>>3. **Сохранение состояния**:
>>     - Замыкания позволяют сохранять состояние между вызовами функций.
>>        Главное - ***сохранить ссылку на возвращаемый объект***, чтобы иметь доступ к методам и сохранить замыкание.
>>        У каждого присваивания будет свой скоуп.(см Пример Работы с разными вызовами)
>>> [!example]+ Примеры как сохраняется состояние и не сохраняется 
>>>```js
>>>function createCounter() {
>>>    let count = 0;    
>>>    return {
>>>        increment: function() {
>>>            count++;
>>>        },
>>>        getCount: function() {
>>>            return count;
>>>        }
>>>    };
>>>}
>>>```
>>> ###### Использование с присваиванием
>>>```js 
>>>const counter1 = createCounter();
>>>counter1.increment();
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 2
>>>```
>>>
>>> ***Использование как свойства объекта:***
>>>```js 
>>>const obj = {
>>>    counter: createCounter()
>>>};
>>>obj.counter.increment();
>>>console.log(obj.counter.getCount()); // Выведет: 1
>>>```
>>>
>>> ***Передача как аргумента функции:***
>>>```js 
>>>function useCounter(counter) {
>>>    counter.increment();
>>>    console.log(counter.getCount());
>>>}
>>>useCounter(createCounter()); // Выведет: 1
>>>```
>>> ###### Пример Работы с разными вызовами
>>>```js 
>>>const counter1 = createCounter();
>>>const counter2 = createCounter();
>>>
>>>counter1.increment();
>>>console.log(counter1.getCount()); // Выведет: 1
>>>console.log(counter2.getCount()); // Выведет: 0
>>>```
>>>###### Использование без присваивания
>>>```js 
>>>console.log(createCounter().getCount()); // Всегда выведет: 0
>>>createCounter().increment();
>>>console.log(createCounter().getCount()); // Все равно выведет: 0
>>>```
>
>>[!example]
>> ###### Пример простого замыкания:
>>```js
>>function outerFunction(x) {
>>    let y = 10;    
>>    function innerFunction() {
>>        console.log(x + y);
>>    }    
>>    return innerFunction;
>>}
>>const closure = outerFunction(5);
>>closure(); // Выведет: 15
>>```
>>
>>В этом примере `innerFunction` является замыканием. Она "запоминает" значения `x` и `y`, даже после того, как `outerFunction` завершила свое выполнение.
>> ###### Пример инкапсуляции и приватных переменных:
>>```js
>>function createCounter() {
>>    let count = 0;    
>>    return {
>>        increment: function() {
>>            count++;
>>        },
>>        getCount: function() {
>>            return count;
>>        }
>>    };
>>}
>>const counter = createCounter();
>>counter.increment();
>>counter.increment();
>>console.log(counter.getCount()); // Выведет: 2
>>console.log(counter.count); // Выведет: undefined
>>```
# каррирование
> [!help] 
>>[!quote]
>> **Каррирование (Currying)** - это техника в функциональном программировании, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает один аргумент. `funcName(1)(2)(3)`
>
> Основная идея каррирования заключается в том, чтобы сделать функции более гибкими и переиспользуемыми. Хотя каррирование не используется так часто, как некоторые другие паттерны, оно может быть очень полезным в определенных ситуациях.
>
>>[!example] Базовый пример каррирования:
>>```js 
>>// Обычная функция
>>function add(a, b, c) {
>>    return a + b + c;
>>}
>>
>>// Каррированная версия
>>function curriedAdd(a) {
>>    return function(b) {
>>        return function(c) {
>>            return a + b + c;
>>        }
>>    }
>>}
>>
>>console.log(add(1, 2, 3)); // 6
>>console.log(curriedAdd(1)(2)(3)); // 6
>>
>>// Частичное применение
>>const add1 = curriedAdd(1);
>>const add1And2 = add1(2);
>>
>>console.log(add1And2(3)); // 6
>>```

# прототипное наследование
> [!help] 
>>[!quote]
>**Прототипное наследование** в JS — это механизм, с помощью которого объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. Это позволяет избежать дублирования кода и позволяет объектам использовать свойства и методы своих "родителей".
> ###### Как работает прототипное наследование?
>>Когда ты пытаешься получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте.
>>Если свойство или метод не найдено, JavaScript продолжает поиск в прототипе объекта (то есть в объекте, от которого наследуется текущий объект).
>>Этот процесс продолжается до тех пор, пока не найдётся нужное свойство или не достигнут объект без прототипа (обычно это `null`).
>>>[!example] Пример базового прототипного наследования
>>>```javascript
>>> const animal = {
>>>  speak() {
>>>    return "Animal sound";
>>>  }
>>>};
>>>```
>>>```javascript
>>>const dog = {
>>>  bark() {
>>>    return "Woof!";
>>>  }
>>>};
>>>// Назначаем animal прототипом для dog
>>>Object.setPrototypeOf(dog, animal);
>>>
>>>console.log(dog.bark());   // "Woof!" - метод dog
>>>console.log(dog.speak());  // "Animal sound" - метод наследован от animal
>>
> ###### Методы для работы с прототипами
>> 1. **Object.setPrototypeOf()** - используется для назначения прототипа для объекта. Это современный и предпочтительный метод по сравнению с устаревшим `__proto__`.
>>>```javascript
>>>const animal = { legs: 4 };
>>>const cat = {};
>>>// Назначаем animal как прототип для cat
>>>Object.setPrototypeOf(cat, animal);
>>>
>>>console.log(cat.legs); // 4
>> 2. **Object.getPrototypeOf()** - возвращает прототип объекта, то есть объект, от которого он наследует.
>>>```javascript
>>>const proto = Object.getPrototypeOf(cat);
>>>console.log(proto); // { legs: 4 }
>>>console.log(proto === animal); // true
>>
> ###### Почему не используют `__proto__`
>>**`__proto__`** — это старый способ манипулирования прототипами, который считается небезопасным и неэффективным. Использование `Object.setPrototypeOf` и `Object.getPrototypeOf` предпочтительнее из-за лучшей производительности и поддержки стандартов.
>>```javascript
>>// Устаревший способ
>>cat.__proto__ = animal;
> ###### Изменение прототипа и его влияние
>>Когда ты изменяешь свойства или методы объекта-прототипа, это изменение отразится на всех объектах, которые используют этот объект в качестве прототипа.
>>```javascript
>>const bird = {
>>  fly() {
>>    return "Flying";
>>  }
>>};
>>
>>const eagle = {};
>>Object.setPrototypeOf(eagle, bird);
>>
>>console.log(eagle.fly()); // "Flying"
>>// Изменяем метод в прототипе
>>bird.fly = function() {
>>  return "Soaring!";
>>};
>>
>>console.log(eagle.fly()); // "Soaring!" - наследует изменённый метод
> ###### Примитивы и временные объектные обёртки
>>Примитивы, такие как строки и числа, при вызове методов временно преобразуются в объектные обёртки (String, Number и т.д.), что позволяет работать с методами этих типов данных. Можно добавлять свои методы в их прототипы.
>>>[!example] Пример с добавлением метода в String.prototype
>>>```javascript
>>>String.prototype.reverse = function() {
>>>  return this.split('').reverse().join('');
>>>};
>>>
>>>console.log("hello".reverse()); // "olleh"
> ###### **.prototype** и функции-конструкторы
>>**.prototype** — это специальное свойство функций-конструкторов, которое позволяет задавать методы и свойства для всех объектов, созданных через этот конструктор. Это не используется для обычных объектов.
>>```javascript
>>function Person(name) {
>>  this.name = name;
>>}
>>
>>Person.prototype.greet = function() {
>>  return `Hello, my name is ${this.name}`;
>>};
>>
>>const alice = new Person("Alice");
>>console.log(alice.greet()); // "Hello, my name is Alice"
> ###### Итоговое резюме:
>> **Прототипное наследование** — это механизм, который позволяет объектам наследовать свойства и методы от других объектов через цепочку прототипов.
>> - Используй `Object.setPrototypeOf(obj, proto)` для назначения прототипа объекта.
>> - Используй `Object.getPrototypeOf(obj)` для получения прототипа объекта.
>> - Не используй `__proto__` из-за его устаревшего статуса и низкой производительности.
>> - Изменения в объекте-прототипе отражаются на всех объектах, которые его используют.
>>`.prototype` используется для функций-конструкторов и классов, чтобы создавать общие методы для всех объектов, созданных через них.
>> - Примитивные типы данных, такие как строки и числа, временно преобразуются в объектные обёртки, что позволяет расширять их прототипы методами (например, добавление метода в `String.prototype`).
# event-loop
